[
["index.html", "Un Primer Curso de R Portada", " Un Primer Curso de R Alberto Rodríguez Rodríguez Última actualización: 24 de septiembre de 2020 Portada "],
["Presenta.html", "Presentación", " Presentación Este libro, de naturaleza web, presenta los contenidos que pueden ser abordados en un primer curso orientado al aprendizaje de R. Este lenguaje, como muchos softwares estadísticos o de otra naturaleza, está conformado por una inmensa cantidad de funcionalidades que complejiza su aprendizaje y, desde luego, su enseñanza. Es tal el crecimiento que ha alcanzado R durante los últimos años que hoy el reto, para quienes trabajamos con él, no es estar actualizados sino lo menos desactualizados posibles; nunca, así nos lo propongamos, alcanzaremos a conocer y dominar todas las posibilidades y funcionalidades que R ofrece en la actualidad. El contenido del libro se divide en 5 grandes componentes derivados de un enfóque de aprendizaje desde lo que hoy se conoce, en el contexto de la gestión moderna de datos, como Ciencia de Datos: fundamentos del lenguaje R, limpieza y transformación de datos en R, visualización en R, modelamiento en R y comunicación de resultados en R. Sin importar si se labora en una empresa o se trabaja en el ámbito académico, estos 5 pasos, con mayor o menor medida, deben ser empleados en el proceso de generación de conocimiento a partir de los datos disponibles. Los datos se deben capturar y los mismos son de diversa naturaleza; una vez capturados deben ser importados y trasformados según nuestros intereses; una vez trasformados, para prósitos descriptivos o análiticos, estos deben ser representados de manera gráfica o tabular; agotadas las fases de transformación y visualización, se deben implementar los métodos estadísticos de interés que nos permitan dar respuesta a las preguntas de negocio o de investigación; finalmente, los resultados obtenidos deben ser comunicados a través de diversos medios. Este curso es un intento por crear competencias en los estudiantes que les permita a los mismos enfrentarse a un proceso de gestión de datos con el apoyo de R el cual, como se acaba de ilustrar, va desde la importación de datos hasta la entrega de resultados. Uno de las cosas más interesantes de R y, a su vez, de las más complejas de asimilar en su proceso de aprendizaje es que existen varios caminos -posibilidades- para obtener el mismo resultado. Dos estudiantes pueden llegar al mismo resultado por dos vías diferentes y, entre ellos, presentar dificultad para entender lo que el otro hizo. No obstante, existen unos fundamentos, reglas o bases del lenguaje que son universales y de las cuales se vale el lenguaje para construir el andamiaje hasta hoy existente. Estos fundamentos, desconocidos por buena parte de los usuarios de R, son centrales para un aprendizaje sostenible a lo largo del tiempo. Por lo anterior, este primer curso de R es un intento por enseñar a los estudiantes los principales pasos y fundamentos requeridos para adelantar un análisis de manera independiente a través del uso de este lenguaje. A lo largo del curso, además de su sentido orientado a la práctica y de un intento pedagógico en la presentación e ilustración de los diferentes componentes y conceptos, se irán presentando los fundamentos y las reglas que gobiernan este lenguaje de programación. ¡Bienvenidos! "],
["1-Instalar.html", "Capítulo 1 Instalar R y Rstudio", " Capítulo 1 Instalar R y Rstudio A continuación, se presentan los pasos requeridos para la instalación de R, Rstudio así como la personalización de este último si se considera pertinente por parte de los usuarios. La instalación de estos dos programas es requerida previo al inicio del presente curso. Para ello, primero se debe instalar en cada uno de nuestros equipos R y luego Rstudio. "],
["1-1-instalar-r.html", "1.1 Instalar R", " 1.1 Instalar R A continuación, se presentan los pasos para la instalación de R. Paso 1 El primer paso, como se ilustra en la Figura de abajo, consiste en buscar R en google. Para ello, en la barra de google se ingresa la siguiente palabra “R project”. Paso 2 El segundo lugar, como se ilustra en la Figura de abajo, se debe dar clic en la opción “Download R” Paso 3 En tercer lugar, como se ilustra en la Figura de abajo, se abre una ventana con las diferentes opciones disponibles para descargar R Paso 4 En cuarto lugar, como se ilustra en la Figura de abajo, se debe seleccinar R de acuerdo al sistema operativo disponible en nuestros computadores. La gran mayoría de nuestros PCs tienen instalado Windows. Paso 5 El quinto lugar, como se ilustra en la Figura de abajo, se debe dar clic en la opción base. Paso 6 En sexto lugar, como se ilustra en la Figura de abajo, se debe dar clic en la opción Download R 4.0.2 for Windows (32/64 bit) Paso 7 En septimo lugar, como se ilustra en la Figura de abajo, se debe dar sí en la ventana emergente. Esta ventana, según los esquemas de seguridad instalados en nuestros computadores, puede o no emerger. Si no emerge, pasa directamente al paso 8. Paso 8 En octavo lugar, como se ilustra en la Figura de abajo, se debe seleccionar la opción instalar y luego dar clic en Aceptar. Paso 9 En noveno lugar, como se ilustra en la Figura de abajo, se debe dar clic en Siguiente en la totalidad de pestañas que aparecen a continuación. Paso 10 En decimo lugar, como se ilustra en la Figura de abajo, se debe esperar a que termine la instalación de R. Este paso puede tardar algunos minutos. Paso 11 En onceavo lugar, como se ilustra en la Figura de abajo, una vez se ha instalado el programa, se debe dar clic en la opción “Finalizar”. Paso 12 En doceavo lugar, como se ilustra en la Figura de abajo, se debe verificar que R quedó instalado en nuestros equipos. Esto se puede hacer a través de la barra de opciones de programas. "],
["1-2-instalar-rstudio.html", "1.2 Instalar Rstudio", " 1.2 Instalar Rstudio Una vez hemos instalado R en nuestros computadores, el paso a seguir es instalar Rstudio. Para ello, procedemos a ejecutar los siguientes pasos. Paso 1 El primer paso, como se ilustra en la Figura de abajo, consiste en buscar Rstudio en google. Para ello, en la barra de google se ingresa la siguiente palabra “r studio”. Paso 2 En segundo lugar, como se ilustra en la Figura de abajo, se deve dar clic en la opción Download Rstudio - Rstudio Paso 3 En tercer lugar, como se ilustra en la Figura de abajo, en la parte baja de la ventana se debe dar clic en la opción *DOWNLOAD; la que está debajo de la opción Free. Paso 4 En cuarto lugar, como se ilustra en la Figura de abajo, se debe dar clic en la opción DOWNLOAD RSTUDIO FOR WINDOWS. Paso 5 En quinto lugar, como se ilustra en la Figura de abajo, se debe dar sí en la ventana emergente. Esta ventana, según los esquemas de seguridad instalados en nuestros computadores, puede o no emerger. Si no emerge, pasa directamente al paso 6. Paso 6 En sexto lugar, como se ilustra en la Figura de abajo, en la ventana emergente dar clic en la opción Siguiente y de allí, en adelante, dar siguiente a todas las ventanas que aparezcan hasta que inicie la descarga del programa. Paso 7 En septimo lugar, como se ilustra en la Figura de abajo, una vez el software es descargado en nuestros equipos, se debe dar clic al archivo descargado e iniciar su proceso de instalación. El proceso de instalación de Rstudio puede tardar algunos minutos. Paso 8 En octavo lugar, como se ilustra en la Figura de abajo, una vez a finalizado el proceso de instalación, se debe dar clic en la opción Terminar. Paso 9 En noveno lugar, como se ilustra en la Figura de abajo, se debe verificar que Rstudio quedó instalado en nuestros equipos. Esto se puede hacer a través de la barra de opciones de programas. "],
["1-3-personalizar-rstudio.html", "1.3 Personalizar Rstudio", " 1.3 Personalizar Rstudio Una vez hemos instalado de manera correcta R y Rstudio, el último paso a seguir es el de la personalización de Rstudio de acuerdo a cada una de nuestras necesidades o preferencias (este paso es opcional). Para ello, iniciamos Rstudio desde nuestro equipos y una vez abra, vamos a la pestaña Tools y damos clic en la opción Global Options (ver figura de abajo). Paso 1 Paso 2 En la ventana emergente, como se ilustra en la figura de abajo y, entre otras opciones, podemos personalizar el tamaño de la letra a usar Rstudio así como el color de fondo del mismo. Yo, por ejemplo, uso el tamaño de letra asignado por defecto (11) y como color de fondo uso la opción Cobalt. "],
["2-Fund.html", "Capítulo 2 Fundamentos del lenguaje R", " Capítulo 2 Fundamentos del lenguaje R En esta sección, se presentan los fundamentos del lenguaje de programación R. Estos están constituidos por los principales tipos de datos existentes en R, las operaciones aritméticas, la creación de variables, las expresiones lógicas, las estructuras de datos, la indexación o creación de subconjuntos de datos en R así como las principales rutinas de programación que hacen parte de este lenguaje. "],
["2-1-introR.html", "2.1 Primeros pasos", " 2.1 Primeros pasos R, como los demás lenguajes de programación, se ejecuta a través de un conjunto de instrucciones que se alojan dentro de un documento llamado programa, script o código conformado por líneas de código y comentarios. Para que un scrip o código pueda ser entendido por nuestras computadoras, estos imponenen algunas reglas básicas. A lo largo de este libro se presentarán, con títulos en color rojo, las reglas básicas del lenguaje de programación R; estas, como toda regla, nunca deben ser violadas.1 La primera regla de R está relacionada con los comentarios. Es decir, la forma como se documenta un código o programa y que el contenido de estos no sean tenidos en cuenta a la hora de la ejecución/compilación de los mismos. Los comentarios son de suma importancia para entender/explicar el contenido o las acciones adelantadas dentro de un programa. Estos son de suma utilidad para nosotros mismos, al momento de olvidar los porqués del contenido que construimos en un código en el pasado o, para otra u otras personas, al momento de intendar comprender/entender el contenido de nuestros programas. Regla: Comentarios En R, los comentarios; es decir, las partes que nos permiten documentar un código se anteceden de la letra numeral #. Los comentarios, en el momento de ejecutar un código, no son tenidos en cuenta por nuestras computadoras. A continuación, se presenta un ejemplo de un comentario en R. # Este es un comentario en R R, como se mencionó al inicio de esta sección, se ejecuta a través de un programa o script el cual está confomado por un conjunto de instrucciones y comentarios que nos permiten obtener los resultados deseados. A continuación, se presenta un ejemplo de un script, programa o código en R.2 Ejemplo. Script, programa o código en R # Ejemplo de un script, programa o código en R. x &lt;- 1 # Esta es una línea de código y &lt;- 2 x + y # Esta es otra línea de código El programa de R que se acaba de presentar está conformado por tres líneas de código: la primera, conformada por una variable x, a la que se le asigna el valor 1; la segunda, conformada por una variable y, a la que se le asigna el valor 2 y, finalmente, la tercera línea de código, arroja el resultado de sumar los valores contenidos en la variables x e y. Cada una de las líneas de un programa, como se mencionó previamente se conoce como línea de código y solo puede existir una instrucción por línea de código. Esta condición deriva en la siguiente regla en R. Regla: Instrucciones por línea R solo permite una instrucción por cada una de las líneas que conforman un código o script. En consecuencia, si se ingresan dos o más instrucciones en una misma línea de un código, este genera un error. A continuación, se presentan dos ejemplos de programas en R. El primero con una instrucción por línea de código (programa correcto) y el segundo con más de una instrucción po línea de código (programa incorrecto). Al ejecutar el programa incorrecto, el que viola la regla de más de una instrucción por línea de código (el segundo), el programa retornará un error. Ejemplos. Programas correctos e incorrectos en R # Ejemplo 1. Código o script correcto (una instrucción por línea) x &lt;- 1 y &lt;- 2 x + y # Ejemplo 2. Código o script incorrecto (más de una instrucción por línea) x &lt;- 1 y &lt;- 2 x + y El lenguaje de programación R, a diferencia de otros lenguajes, diferencia entre letras mayúsculas y minúsculas (Case Sensitive). Este hecho, implica la siguiente regla en este lenguaje. Regla: Mayúsculas y Minúsculas - (Case Sensitive) R, a diferencia de otros lenguajes de programación, distingue/diferencia entre letras mayúsculas y minúsculas (Case Sensitive). Es decir, una letrá mayúscula es diferente a su contraparte en minúscula. Ejemplos. Letras mayúsculas y minúsculas A continuación, se presentan cuatro ejemplos en el que se refleja la importancia de diferenciar las letras mayúsculas y minúsculas en R. En el primero de ellos, el mismo programa expuesto con anterioridad, se presenta un programa con el uso de letras minúsculas. El segundo, el mismo programa con el uso de letras mayúsculas. El tercero, el mismo programa con una combinación correcta de letras mayúsculas y minúsculas. Finalmente, el ejemplo cuatro, presenta el mismo programa con una combinación/uso inorrecto de letras mayúsculas y minúsculas que implica un error en el mismo. En este último ejemplo, el valor 1 se asigna a la letra mayúscula X, el valor 2 a la letra mayúscula Y pero, la suma de los mismos -tercera línea de código-, se representa mediante las letras minúsculas x e y cuando se espera que allí se ubiquen sus contrapartes mayúsculas. # Ejemplo 1. Script con letras minúsculas. x &lt;- 1 y &lt;- 2 x + y # Ejemplo 2. Script con letras mayúsculas. x &lt;- 1 Y &lt;- 2 x + Y # Ejemplo 3. Scrip con letras mayúsculas y minúsculas. X &lt;- 1 y &lt;- 2 X + y # Ejemplo 4. Error. Mal uso de letras mayúsculas y minúsculas. X &lt;- 1 Y &lt;- 2 x + y A lo largo de los capítulos que conforman este documento se presentarán algunos casos en los cuales estas reglas pueden ser obviadas o ajustadas. Las reglas que permiten estas acciones pueden ser consideradas como reglas débiles.↩︎ En adelante, haremos uso de la palabra programa para hacer referencia a un script o código de R.↩︎ "],
["2-2-Tdatos.html", "2.2 Tipos de datos", " 2.2 Tipos de datos Esta sección contiene los principales tipos de datos utilizados en R. Aunque existen otros tipos de datos los cuales no serán objeto del presente documento, estos se caracterizan por conformar la base del lenguaje. 2.2.1 Tipos de datos en R En R existen 5 tipos de datos básicos: lógicos, numéricos, numéricos - enteros, cadena/caracter y complejos3. A continuación se presenta una breve descripción y se ejemplifican cada uno de estos tipos de datos. Lógicos Los tipos de datos lógicos, también conocidos como booleanos, representan en R falso o verdadero y se representan mediante las letras o palabras mayúsculas F o FALSE para el caso de falso y T o TRUE para el caso de verdadero. NOTA: En los ejemplos que se presentan a continuación y en muchos de los que se presentarán en adelante, el contenido de los mismos tiene dos componentes: el texto del programa el cual está acompañado de colores en su texto y el resultado u output que arroja R al ejecutar/compilar el programa el cual, además de presentarse en letras de color negro, está precedido de un doble numeral (##). A continuación se ejemplifican los resultados de compilar tipos de datos lógicos o booleanos en R. Ejemplo. Datos lógicos # Opciones para verdadero (T o TRUE) # Con T T ## [1] TRUE # Con TRUE TRUE ## [1] TRUE # Opciones para falso (F o FALSE) # Con F F ## [1] FALSE # Con FALSE FALSE ## [1] FALSE Auque es correcto y más corto el uso de las letras T o F para representar las condiciones de falso o verdadero en R, se recomienda siempre usar las versiones TRUE o FALSE por ser estas más consistentes. Numéricos Los tipos de datos numéricos, también conocidos como numéros, datos decimales o dobles, hacen referencia a aquellos números (positivos o negativos) que se caracterizan por estar conformados por una parte entera y una decimal.En R, el punto (.) es el encargado de separar la parte entera de la parte decimal de un número. Por ejemplo, 3.14, 30.48, 2.05, son representaciones de números en R. Cuando un número es muy grande o muy pequeño, por defecto, el programa los representa mediante notación científica haciendo uso de la letra (e). Por ejemplo, 1e-11 es la representación notación/científica4 del número real 0.00000000001. A continuación, se presentan algunos ejemplos en R de datos numéricos o decimales. Ejemplo. Datos numéricos/decimales # numéros reales convencionales 3 ## [1] 3 3.14 ## [1] 3.14 30.48 ## [1] 30.48 2.05 ## [1] 2.05 # numéros reales grandes - notación científica 1234567891011 ## [1] 1.234568e+12 # número reales pequeños - notación científica 0.00000000001 ## [1] 1e-11 Regla: Números por defecto en R En R, a menos que se diga lo contrario, todo número, por defecto, es considerado numérico. Enteros - numéricos Los tipos de datos enteros en R, también conocidos como números enteros, son aquellos que a diferencia de los numéricos, carecen de una parte decimal. Los número enteros en R están acompañados de la letra mayúscula (L). Por ejemplo, 3L representa el número entero 3 y -10L el número entero -10. Ejemplo. Datos enteros A continuación, se presentan algunos ejemplos de números enteros en R. # Enteros positivos 5L ## [1] 5 3L ## [1] 3 # Enteros negativos -20L ## [1] -20 -1L ## [1] -1 Cadena o caracter En R, los datos de tipo cadena o caracter hacen referencia a aquellos datos que contienen texto en su contenido. Los tipos de dato caracter o de texto en R se representan/encierran mediante comillas dobles \" o sencillas ’ pero núnca a través de una mezcla o combinación entre los dos tipos de comillas. “Hola mundo”, “Este es un dato de tipo texto”, ‘dato entre comillas sencillas’, “dato entre comillas dobles” son algunos ejemplos de datos de tipo cadena, texto o caracter en R. Ejemplo. Datos cadena/caracter A continuación, se presentan algunos ejemplos de datos de tipo cadena o caracter en R. Así mismo, el segundo de los ejemplos, presenta dos ejemplos que combinan comillas dobles y simples hecho que, como ya se mencionó, conducen a un error en R. # Ejemplo 1 # Con comillas dobles &quot;Hola&quot; ## [1] &quot;Hola&quot; &quot;Este es otro dato de tipo texto&quot; ## [1] &quot;Este es otro dato de tipo texto&quot; &quot;TRUE&quot; ## [1] &quot;TRUE&quot; # Con comillas sencillas &#39;dato entre comillas sencillas&#39; ## [1] &quot;dato entre comillas sencillas&quot; &#39;FALSE&#39; ## [1] &quot;FALSE&quot; &#39;2.35&#39; ## [1] &quot;2.35&quot; # Ejemplo 2 # Con comillas mezcladas (dobles y simples) &quot;Hola&#39; &#39;Hola mundo&quot; # Las anteriores dos líneas de código producen errores en R 2.2.2 Constantes integradas en R R, por defecto y de manera especial trae incluido un pequeño número de variables/palabras (5) que permiten la visualización de ciertos datos de tipo numérico o caracter de alto uso entre los usuarios, en especial, los de habla inglesa. A continuación, se presentan los cinco nombres especiales que trae incluido este software así como sus correspondientes significados. LETTERS: las 26 letras mayúsculas del alfabeto romano letters: las 26 letras minúsculas del alfabeto romano month.abb: abreviaturas de tres letras para los nombres de los meses en inglés month.name: los nombres en inglés de los meses del año pi: la relación entre la circunferencia de un círculo y su diámetro. También conocido como número pi. Ejemplo. Constantes integradas en R A continuación, se presenta el resultado de las constantes o palabras integradas y utilizadas por R. # Letras del abecedario en mayúsculas. LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # Letras del abecedario en minúsculas. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; # Primeras tres letras de los nombres de los meses - en inglés. month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; # Nombre de los meses - en inglés. month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; # Número pi pi ## [1] 3.141593 En este documento no haremos referencia a los números complejos. Estos, de amplio uso y estudio en el contexto de las matemáticas, se caracterízan por tener una parte entera y una imaginaria↩︎ El número de decimales a partir del cual R representa a los números reales en notación científica se da por defecto y el mismo, si se considera necesario, puede ser modificado↩︎ "],
["2-3-Aritmet.html", "2.3 Operaciones aritméticas", " 2.3 Operaciones aritméticas En esta sección se presentan las principales operaciones aritméticas empleadas en R. 2.3.1 Operaciones aritméticas en R R, en sentido estricto, puede ser considerado como una calculadora avanzada. A través de él es posible implementar las operaciones simples de la aritmética (básicas y complementarias) así como algunas operaciones avanzadas que van desde la combinación de las operaciones simples (compuestas) hasta su uso para otro tipo de operaciones (funciones trigonométricas, operaciones logarítmicas, potenciación, uso de radicales, etc.). En este texto, dado su caracter introductorio, se presentan las operaciones aritméticas simples (básicas o complementarias) así como algunas operaciones compuestas derivadas de la aplicación/combinación de dos o más operaciones simples. Operaciones aritméticas simples: Las operaciones aritméticas básicas o simples empleadas por R son la suma (+), la resta (-), la multiplicación (*) y la división (/). Ejemplos. Operaciones aritméticas básicas A continuación, se presentan algunos ejemplos con las principales operaciones simples empleadas por R. # Suma 3.5 + 7.7 ## [1] 11.2 3L + 10L ## [1] 13 1 + 8 ## [1] 9 # Resta 7.7 - 3.7 ## [1] 4 3L - 10L ## [1] -7 8 - pi ## [1] 4.858407 # Multiplicación 7.71 * 3.73 ## [1] 28.7583 -3L * 10L ## [1] -30 1 * 8 ## [1] 8 # División 7.7 / 3.7 ## [1] 2.081081 12L / 4L ## [1] 3 -1 / 4 ## [1] -0.25 Operaciones aritméticas simples complementarias: Las operaciones aritméticas simples y complementarias empleadas por R son los exponentes (^), la división entera (%/%) y los módulos (%%). A continuación, se presenta una breve descripción de estos tres subtipos de operaciones simples complementarias. Exponentes: Consiste en elevar un número x a una potencia n. Es decir, multiplicar x por sí mismo tantas veces como se defina en n (ver siguiente fórmula). \\[\\begin{equation} x^n \\end{equation}\\] Por ejemplo, \\[\\begin{equation} 2^3 \\end{equation}\\] consiste en multiplicar el número 2 por sí mismo 3 veces; es decir, 2x2x2 cuyo resultado es igual a 8. Divisón Entera: La división entera de x%/%n devuelve el número máximo de veces que se encuentra un núemro n contenido dentro de un número x. Módulo: El módulo de una división x%%n devuelve el residuo o resto de la división entera de un número x por un número n. Ejemplos. Operaciones aritméticas complementarias A continuación, se presentan algunos ejemplos de operaciones aritméticas simples y complementarias en R. # Exponenciales 2^3 ## [1] 8 3^2 ## [1] 9 5^3 ## [1] 125 # Divisiones enteras 15%/%3 ## [1] 5 17%/%3 ## [1] 5 9%/%4 ## [1] 2 # Módulos 15%%3 ## [1] 0 17%%3 ## [1] 2 9%%4 ## [1] 1 Operaciones compuestas Una operación aritmética compuesta está conformada por la combinación de varias operaciones simples (sumas, restas, multiplicaciones, divisiones, exponentes, etc.). Ejemplos. Operaciones complejas A continuación, se presentan algunos ejemplos de operaciones aritméticas compuestas. 2 + 2 + 3*2 ## [1] 10 2*5 - 6/2 ## [1] 7 6/2*10/2 + 3 ## [1] 18 6/2*(2+1 + 2^3) ## [1] 33 Al observar detenidamente Los ejemplos de las operaciones aritméticas compuestas que se acaban de ilustrar, nos podemos dar cuenta que estas contienen sumas, restas, multiplicaciones y hacen uso de exponentes y paréntesis. Una pregunta que podría surgir de este hecho es ¿cuál es el orden en el que R calcula estas operaciones?. La respuesta a esta pregunta está contenida en una regla llamada de priorización o precedencia. Regla: Precedencia o priorización en operaciones aritméticas compuestas En una operación aritmética compuesta de R, los paréntesis se calculan primero, luego los exponentes, luego la división y multiplicación y, finalmente, la suma y la resta. Esta regla se conoce popularmente como PEMDAS5 En la siguiente ilustración se presenta un ejemplo de la importancia del conocimiento de la regla de priorización o precedencia en R. En esta ilustración las dos operaciones están compuestas de los mismos números, no obstante, los resultados obtenidos son diferentes (17 y 25). En la operación de la parte izquierda (Order by default), la regla PEMDAS indica que primero debemos realizar la multiplicación y luego la suma; en contraste, en la operación de la parte derecha (Using parentheses), la regla de precedencia nos dice que primero dedemos realizar las operaciones contenidas dentro de los paréntesis -la suma- y luego la multiplicación. Ilustración. Prioridad aritmética en R En el siguiente ejemplo se presentan los resultados obtenidos en R al desarrollar las dos operaciones contenidas en la anterior ilustración. Ejemplo. Ilustración de aplicación de regla de precedencia o priorización en operaciones aritméticas compuestas # por defecto 2 + 3*5 ## [1] 17 # usando paréntesis (2 + 3)*5 ## [1] 25 El conocimiento y uso de la regla de priorización o precencia PEMDAS tiene importantes implicaciones prácticas y técnicas las cuales han generado debate en la comunidad científica y se han convertido en una de las principales fuentes de error a la hora de enfrentarnos al desarrollo de operaciones artitméticas compuestas. El siguiente artículo, publicado en el diario el Espectador por el profesor Ignacio Mantilla, exrector de la Universidad Nacional de Colombia, muestra la importancia del tema el cual, como puede allí leerse, tiene implicaciones de alcance a nivel tecnológico. Invitamos al lector a explorar y analizar detenidamente el contenido de este artículo. Ver artículo directamente en: Ecuaciones de opinión Tipos de datos de expresiones numéricas El resultado de una operación aritmética (simple o compuesta) es un número. No obstante, como se acaba de presentar, los tipos de datos numéricos en R pueden ser de dos tipos: numéricos -en sentido estricto- o enteros. En este orden de ideas, una pregunta que surge al desarrollar una operación aritmética es: ¿cuál es el tipo de dato que resulta al implementar una operación aritmética en R? La respuesta a esta inquietud se presenta en la siguiente regla de este lenguaje. Regla: Tipos de datos resultantes de operaciones aritméticas En R, operaciones entre datos del mismo tipo, producen el mismo tipo de datos. En contraste, operaciones entre diferentes tipos de datos, producen el tipo de dato más elevado de acuerdo al siguiente ordenamiento (Numérico &gt; Entero &gt; Lógico) Al observar la segunda parte de la anterior regla llama la atención la inclusión de los tipos de datos lógicos o booleanos como un tipo de dato numérico en R. Pues bien, en este lenguaje de programación, el tipo de dato lógico FALSE es equivalente a 0 y el tipo de dato lógico TRUE es equivalente al valor 1. Este hecho, conlleva a la definición de la siguiente regla del lenguaje. Regla: Comportamiento numérico de los datos lógicos o booleanos En R, los tipos de datos booleanos (FALSE y TRUE), además de representar las condiciones de falso y verdadero, en términos numéricos, presentan las siguiente equivalencias: TRUE = 1 y FALSE = 0 Como consecuencia de la anterior regla, en R y aunque no se recomienda su uso, una operación aritmética (simple o compuesta), puede incluir datos de tipo booleano y el tipo de dato resultante sigue la regla del dato más elevado según el criterio antes presentado (Numérico &gt; Entero &gt; Lógico). A continuación, se presentan algunos ejemplos de operaciones aritméticas que involucran diversos tipos de datos. Invitamos al lector, de acuerdo a las dos reglas antes expuestas, a responder ¿cuál es el tipo de dato que resulta al desarrollar dichas operaciones? Ejemplo. Tipos de datos resultantes de expresiones numéricas 1L + 2L + 2L ## [1] 5 3L + 2 ## [1] 5 3L + 3*3 + 5/2 ## [1] 14.5 FALSE + 4 ## [1] 4 TRUE + FALSE ## [1] 1 FALSE + TRUE ## [1] 1 FALSE + FALSE ## [1] 0 TRUE + TRUE ## [1] 2 La sigla PEMDAS se derivada del inglés para Parentheses (Paréntesis), Exponents (Exponentes), Multiplication-Division (Multiplicación-División), Addition-Subtraction (Suma y resta).↩︎ "],
["2-4-Variables.html", "2.4 Variables", " 2.4 Variables Una de las funcionalidades y de las partes más importantes en el aprendizaje de R es la creación de variables. Una variable en R es un espacio reservado en memoria el cual está compuesto por un nombre y un contenido definido o asignado a este nombre. A continuación, se presenta un ejemplo de una variable en R. # ejemplo de una variable en R x &lt;- 5L En el ejemplo, hemos creado una variable llamada x y a esta se le ha asignado el valor/número entero 5. En R, el simbolo de asignación6 es &lt;-. El uso de variables en R es altamente frecuente pues a través de estas podemos reservar contenidos de nuestros procesos que serán usados en fases posteriores de nuestros análisis. Para mostrar el contenido de una variable en R, además de definir la variable, se debe adicionar una nueva línea de código a nuestros programas con el nombre de la variable o las variables cuyo contenido deseamos conocer. Por ejemplo, si deseamos conocer el contenido de la variable x definida en el ejemplo anterior, debemos adicionar una nueva línea de código con dicho nombre como se presenta a continuación. Ejemplo. Visualización del contenido de una variable en R # Visualización del contenido de una variable en R x &lt;- 5L x ## [1] 5 A continuación, se presentan otros ejemplos de visualización de variables en R. Ejemplo. Visualización del contenido de otras variables en R # Visualización del contenido de variables en R # Ejemplo 1 y &lt;- 5 + 3.2 y ## [1] 8.2 # Ejemplo 2 y &lt;- 1 + pi y ## [1] 4.141593 # Ejemplo 3 z &lt;- 5 + 3*(1 + 2^2) z ## [1] 20 # Ejemplo 4 x &lt;- 3 + 5 y &lt;- 4 x + y ## [1] 12 2.4.1 Nombre de variables Una vez que tenemos claro el objetivo con la creación de variables en R, el paso a seguir consiste en presentar algunas recomendaciones y restricciones a la hora de crear variables en R. Para ello, haremos uso de la siguiente regla en la que se presentan los criterios con las recomendaciones y las restricciones que deben ser tenidas en cuenta a la hora de crear nombres asociados a variables en R. Regla: Nombres de variables en R (recomendaciones y restricciones) En R, para nombrar una variable, existen 5 criterios o reglas que deben ser tenidas en cuenta: Los nombres de las variables consisten en letras (mayúsculas o minúsculas), números, un punto (.) o un guión bajo (_). Podemos comenzar un nombre de variable con una letra o un punto, pero los puntos no pueden ser seguidos por un número. No podemos comenzar un nombre de variable con un número. No se permiten caracteres especiales, por ejemplo, espacios, símbolos de operadores, paréntesis. No podemos usar una palabra clave ya utilizada e interpretada por R como un nombre de variable (Palabras Reservadas). Por ejemplo, if, else, for, while, break, next, repeat, NA, NULL y NaN El contenido de los criterios presentados en la anterior regla se ilustra, con algunos ejemplos de nombres válidos y no válidos para variables en R, a través de la figura que se presenta a continuación. Ilustración. Nombres correctos e incorrectos para nombrar variables en R Además de los criterios presentados en la regla para la asignación de nombres de variables en R, se recomienda que el nombre que se asigne a estas se corresponda con el contenido de las mismas. Por ejemplo, si en una variable se aloja la edad de una persona, sería conveniente que esta variable se llame o nombre como edad. De la misma manera, aunque R permite que los nombres de las variable sean grandes (alta cantidad de caractéres), se recomienda que los mismos no sean demasiado largos. Finalmente, aunque no se recomienda, es normal encontrar en la práctica interesados en nombrar variables con nombres compuestos separados por espacios. Si este es el caso, los nombres compuestos de estas variables deben estar contenidos dentro de comillas a la izquierda. A continuación, se presentan tres ejemplos con nombres de variables compuestos. # Ejemplo 1 `Nombre variable` &lt;- 4.5 # Ejemplo 2 `Nombre compuesto` &lt;- 0 # Ejemplo 3 `Este es otro nombre para mi variable` &lt;- -10L 2.4.2 Tipos de variables El trabajo con variables en R, como ya se mencionó, es altamente frecuente hecho que conlleva a que en algunos casos olvidemos el tipo de elementos que estas contienen. Para ello, en R existe una función7 llamada class() que nos permite conocer la tipología de los elementos que hacen parte de una variable. A continuación, a modo de ejemplo, se definen 5 variables, se expone su contenido y se indaga, haciendo uso de la función class, por los tipos de datos que estas variables contienen. Ejemplo. Tipos de variables en R # Ejemplo 1 var_1 &lt;- TRUE var_1 ## [1] TRUE class(var_1) ## [1] &quot;logical&quot; # Ejemplo 2 var_2 &lt;- 2L var_2 ## [1] 2 class(var_2) ## [1] &quot;integer&quot; # Ejemplo 3 var_3 &lt;- 0.14 var_3 ## [1] 0.14 class(var_3) ## [1] &quot;numeric&quot; # Ejemplo 4 var_4 &lt;- var_1 + var_2 + var_3 var_4 ## [1] 3.14 class(var_4) ## [1] &quot;numeric&quot; # Ejemplo 4 var_5 &lt;- LETTERS var_5 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; class(var_5) ## [1] &quot;character&quot; El tipo de dato contenido en la variable del ejemplo 1 (var_1) es de tipo lógico, el de la variable 2 (var_2) es de tipo entero, el de las variable 3 y 4 (var_3 y var_4) es de tipo numérico y, finalmente, el tipo de dato contenido en la variable del ejemplo 5 (var_5) es de tipo cadena o caracter. También pueden ser empleados, como símbolos de asignación, las expresiones = o -&gt;. Para el último de estos casos las partes contenidas dentro de una variable deben ser invertidas (5 -&gt; x). Aunque las tres formas de asignación (&lt;- , = , -&gt;) son válidas, se recomienda el uso de la primera (&lt;-) para evitar confusiones, en el caso de la igualdad, cuando este sea usado en el contexto de las funciones y en, en el otro caso (-&gt;), por ser contraintuitivo al pensamiento humano↩︎ Esta es la primera vez que hacemos uso, dentro de este documento, de una función. R, en sentido estricto, es un lenguaje de tipo funcional; es decir, altamente/totalmente soportado en funciones. Más adelante se contará con una sección dedicada al uso y construcción de funciones en R↩︎ "],
["2-5-Elogicas.html", "2.5 Expresiones lógicas", " 2.5 Expresiones lógicas Una expresión lógica en R está compúesta por dos componentes mediados por operadores que pueden ser de dos tipos: relacionales o lógicos. A continuación, se presenta un ejemplo con una operación lógica en R. Esta, como se mencionó, está compuesto de dos partes (izquierda y derecha) y es mediada por un operador lógico (&gt;=). En específico, la expresión lógica del siguiente ejemplo indaga si el número 5 (parte izquierda) es mayor o igual &gt;= (operador relacional) que el número 4 (parte derecha). # Ejemplo de una expresión lógica 5 &gt;= 4 El resultado de una operación lógica es un dato de tipo booleano (TRUE o FALSE)8. Este hecho, implica la siguiente regla aplicable a este lenguaje de programación. Regla: Resultado de expresiones lógicas En R, el resultado de una operación lógica, es un dato o literal de tipo booleano (TRUE o FALSE) 2.5.1 Operadores Relacionales Como se mencionó previamente, en R existen dos tipos de operadores asociados a las expresiones lógicas: relacionales y lógicos. Los operadores relacionales disponibles en R son: Menor que ( &lt; ) Mayor que ( &gt; ) Menor o igual que ( &lt;= ) Mayor o igual que ( &gt;= ) Igual a ( == ) No es igual a (diferente) ( != ) A continuación, se presentan algunos ejemplos de expresiones lógicas en R haciendo uso de operadores relacionales con sus respectivos resultados (TRUE o FALSE). Ejemplo. Expresiones lógicas con operadores relacionales # Ejemplo 1 1 &lt; 3 ## [1] TRUE # Ejemplo 2 3 &gt; 3 ## [1] FALSE # Ejemplo 3 4 &lt;= 4 ## [1] TRUE # Ejemplo 4 3 &gt;= 2 ## [1] TRUE # Ejemplo 5 3 == 3 ## [1] TRUE # Ejemplo 6 TRUE == FALSE ## [1] FALSE # Ejemplo 7 TRUE == 1 ## [1] TRUE # Ejemplo 8 FALSE == 0 ## [1] TRUE # Ejemplo 9 3 != 3 ## [1] FALSE # Ejemplo 10 FALSE != 0 ## [1] FALSE # Ejemplo 11 &quot;Uno&quot; != &quot;1&quot; ## [1] TRUE # Ejemplo 12 &quot;Uno&quot; == &quot;Uno&quot; ## [1] TRUE Operaciones lógicas con operaciones aritméticas: Una expresión lógica, además de operadores relacionales, puede involucrar operaciones aritméticas simples, complementarias o compuestas. El ejemplo, que se presenta a continuación, ilustra una expresión lógica que involucra operaciones ariméticas compuestas. Ejemplo. Expresiones lógicas con operadores relacionales y operaciones ariméticas 12.10 - 10.50 &lt; 24.90 * 21.15 ## [1] TRUE Una pregunta que surge, al momento de disponer de una operación lógica que involucra operaciones arirméticas y lógicas es qué evalúa R primero, ¿la operación aritmética o la expresión lógica? La respuesta a esta inquietud conduce a la siguiente regla del lenguaje. Regla: Precedencia en expresiones lógicas En R, al evaluar una expresión lógica que hace uso de operadores relacionales y operaciones aritméticas, primero se evalúan las expresiones aritméticas y luego las expresiones lógicas Operaciones lógicas haciendo uso de variables: El resultado de las operaciones aritméticas, así como de las expresiones lógicas, pueden ser almacenados a través del uso de variables. Es decir, en lugar de evaluar de manera directa una expresión lógica y sus componentes, estos pueden ser evaluados previamente a través del uso de variables. A continuación, se presentan 2 ejemplos de expresiones lógicas en las que se hace uso de variables. Ejemplo. Expresiones lógicas con operadores relacionales y variables # Ejemplo 1 Var_1 &lt;- 12.10 - 10.50 Var_2 &lt;- 24.90 - 21.15 Var_1 &lt; Var_2 ## [1] TRUE # Ejemplo 2 Var_3 &lt;- 12.10 * 12L Var_4&lt;- 4.99 * 24L Var_5 &lt;- Var_3 == Var_4 Var_5 ## [1] FALSE En el ejemplo 1, se crean las variables Var_1 y Var_2 que contienen el resultado de aplicar dos operaciones aritméticas compuestas y, en la tercera línea del código (Var_1 &lt; Var_2), se evalúa la expresión lógica propuesta entre estas dos variables (Var_1 &lt; Var_2). En el ejemplo 2, las variables Var_3 y Var_4 contienen los resultados de dos operaciones aritméticas simples y la variable Var_5 el resultado de la operación lógica definida entre estas dos variables (Var_3 == Var_4). En este ejemplo, la última línea del código (la 4) nos permite visualizar el resultado de la operación lógica implementada a través del uso de variables. 12.10 * 12L == 4.99 * 24L ## [1] FALSE 2.5.2 Operadores Lógicos Los operadores lógicos en R permiten evaluar la condiciones de verdad o de falsedad9 al comparar los resultados entre dos operaciones lógicas relacionales. Los operadores lógicos disponibles en R son: Y lógico ( &amp; ) O lógico ( | ) No lógico ( ! ) Los resultados obtenidos a la hora de la aplicación de los tres operadores lógicos disponibles en R se presentan en el gráfico que se dispone a continuación. El resultado de una operación lógica que involucra el operador lógico &amp; (Y) solamente será cierta (TRUE) cuando las dos condiciones evaluadas sean ciertas. El resultado de una operación lógica que involucra el operador lógico | (O) solamente será falsa (FALSE) cuando las dos condiciones evaluadas sean falsas y, finalmente, el operador de negación (NO) cambia el resultado obtenido (TRUE por FALSE y viceversa). Ilustración Resultado operadores lógicos A continuación, se presnetan los resultados en R de los operadores lógicos expuestos en la anterior imagen. Ejemplo. Resultados expresiones lógicas con operadores lógicos # Con el operador lógico &amp; TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; TRUE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE # Con el operador lógico | TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | TRUE ## [1] TRUE FALSE | FALSE ## [1] FALSE # Con el operador lógico de negación !TRUE ## [1] FALSE !FALSE ## [1] TRUE 2.5.3 Combinando operadores En buena parte de esta sección hemos explorado las posibilidades que nos ofrece R para construir operaciones aritméticas simples o compuestas, disponer los resultados obtenidos dentro de variables así como crear expresiones de tipo lógico las cuales pueden estar asociadas a operadores relacionales o lógicos. Para finalizar esta sección, exploraremos la forma como R evalúa operaciones lógicas que hacen uso de los múltiples conceptos vistos hasta ahora. Para ello, se presenta a modo de ejemplo, la siguiente expresión lógica. # Ejemplo de una expresión lógica compleja (40/2^3) + 2 &gt;= 7 | 5*5 - 5 &lt; 20 Al explorar el contenido de la anterior expresión lógica podemos observar que esta contiene operaciones aritméticas compuestas conformadas por exponentes, sumas, restas, divisiones, multiplicaciones y paréntesis. Así mismo, el ejemplo hace uso de expresiones lógicas asociadas a operadores relacionales y lógicos. La pregunta que surje ahora es: ¿cuál es el resultado de esta operación y cómo R procede para su desarrollo o evaluación? Para dara respuesta a ello, se presenta la siguiente regla del lenguaje la cual puede ser considerada de alcance general ya que incluye otras reglas presentadas hasta ahora. Regla: Precedencia o priorización general en R En R, teniendo en cuenta los operadores vistos hasta ahora y que conforman las operaciones aritméticas y las expresiones lógicas, la regla de priorización general que gobierna la evaluación de dichas expresiones es: Paréntesis Exponentes División y multiplicación Adición y sustracción Operadores relacionales Operadores logicos Es decir, en el ejemplo expuesto anteriormente, en el proceso de evaluación/compilación, el lenguaje primero realiza las operaciones que están dentro de los paréntesis, paso seguido calcula las multiplicaciones, luego las sumas y las restas y, finalmente, evalúa las expresiones lógicas asociadas a operadores relacionales para culminar con la evaluación resultante que involucra a los operadores de tipo lógico. A continuación, se presenta el resultado en R al evaluar la expresión lógica de nuestro ejemplo así como un ejemplo complementario a este. Ejemplo. Resultados expresiones lógicas compuestas # Ejemplo 1 (40/2^3) + 2 &gt;= 7 | 5*5 - 5 &lt; 20 ## [1] TRUE # Ejemplo 2 (40/2^3) + 2 &gt;= 7 &amp; 5*5 - 5 &lt; 20 ## [1] FALSE 2.5.4 Coerción en expresiones lógicas El último componente que abordaremos a la hora de interactuar con expresiones lógicas en R es el principio de coerción que este lenguaje implementa a la hora de evaluar este tipo de expresiones. Para explicar este principio, nos valdremos del siguiente ejemplo. Ejemplo. Filosofía de la coerción en expresiones lógicas # Ejemplo. Coerción en expresiones lógicas &quot;1&quot; == 1 La expresión lógica del ejemplo, que hace uso del operador relacional Igual a:, indaga si el dato de tipo caracter “1” es igual al dato de tipo numérico 1. De manera ligera, es natural pensar que un dato de tipo caracter o textual es diferente a un dato de tipo numérico y que R, para el caso de la igualdad evaluada en el ejemplo, debería retornar como respuesta FALSE. No obstante, la respuesta que retorna el lenguaje al evaluar la operación lógica del ejemplo es TRUE y la pregunta que surge es, ¿por qué? La repuesta a esta inquietud, radica en la siguiente regla que implementa el lenguaje a la hora de evaluar expresiones lógicas conocida como regla de coerción. Regla:Coerción en expresiones lógicas Para que una expresión lógica pueda ser evaluada en R, los componentes de la expresión (partes izquierda y derecha) deben de ser del mismo tipo y para ello hace uso de la siguiente jerarquía según los tipos de datos involucrados en estas. caracter &gt; numérico &gt; entero &gt; lógico Es decir, en la igualdad del ejemplo propuesto \"1\" == 1 R, al detectar que los tipos de datos involucrados en la igualdad son de diferentes tipologías, lo primero que hace es igualarlos según la jereraquía propuesta. Según la regla, un dato de tipo textual o caracter tiene mayor jerarquía que un dato de tipo numérico (caracter &gt; numérico) hecho que conduce a R a convertir el dato de tipo numérico 1 en un dato de tipo textual “1” para garantizar que los tipos de datos involucrados en la expresión lógica sean del mismo tipo. En conclusión, al evaluar la operación lógica \"1\" == 1 en R, por la regla de coherción, lo que el lenguaje efectivamente evaluará es la operación \"1\" == \"1\" cuyo resultado es TRUE. A continuación, se presentan otros ejemplos en lo que se invita al lector a reflexionar sobre la forma como R está aplicando en ellos la regla de coerción. Ejemplo. Coerción en expresiones lógicas # Ejemplo 1. Coerción entre datos de tipo numérico y lógico TRUE == 1 ## [1] TRUE # Ejemplo 2. Coerción entre datos de tipo entero y lógico 1L == TRUE ## [1] TRUE # Ejemplo 3. Coerción entre datos de tipo numérico y entero 1 &gt;= 1L ## [1] TRUE # Ejemplo 4. Coerción entre datos de tipo caracter y entero &quot;1&quot; != 1L ## [1] FALSE # Ejemplo 5. Coerción entre datos de tipo caracter y lógico &quot;0&quot; == FALSE ## [1] FALSE En el ejemplo de la expresión lógica 5 &gt;= 4, el resultado es igual a TRUE dado que 5 es mayor o igual que 4↩︎ Estos operadores hacen parte de lo que en lógica matemática se conoce como tablas de verdad. En R, en el contexto de los operadores se hace uso de las tablas de verdad asociadas a la conjunción (∧), la disyunción (∨) y la negación (¬)↩︎ "],
["2-6-Edatos.html", "2.6 Estructuras de datos", " 2.6 Estructuras de datos En las secciones anteriores se presentaron, principalmente, los tipos de datos de mayor uso en R; la posibilidad de implementar en este expresiones aritméticas a través del uso de operaciones simples y compuestas; la creación y el nombramiento de variables así como la implementación de expresiones lógicas haciendo uso de operadores relacionales y de tipo lógico. En esta sección del documento, nos concentraremos en el estudio de las principales estructuras de datos existentes en R. Una estructura de datos en R, es un artefacto conformado o no por datos del mismo tipo. En este lenguaje, existen 5 estructuras de datos, principalmente: vectores, matrices, arreglos, marcos de datos o data frame y listas10. A continuación, el diagrama, presenta una representación/esquematización gráfica de la arquitectura que hace parte de cada una de las estructuras de datos que serán presentadas en este apartado. Principales estructuras de datos en R. Extraída de https://medium.com/@tiwarigaurav2512/r-data-types-847fffb01d5b 2.6.1 Vectores La primera estructura de datos empleda por R son los vectores. Estos, como se ilustra en la siguiente imagen, están conformados por “filas/columnas” de tipo unidimensional en cuyo interior existen datos de una misma tipología. Representación gráfica de un vector A continuación, se presenta la regla general para la construcción de vectores en R. Regla: Construcción de vectores en R En R, los vectores se construyen haciendo uso de paréntesis precedidos de la letra minuscula c c(). Así mismo, los elementos o tipos de datos que conforman un vector están separados por comas y estos deben ser en su totalidad de la misma tipología. A continuación, se presentan y evalúan dos ejemplos de vectores en R. El primero, está conformado por los números del 1 al 5 (datos de tipo numérico) y el segundo, está conformado por los números enteros del 6 al 10 cuyo resultado es almacenado a través de la conformación/definición de una variable llamada y. Ejemplo. Vectores en R # Ejemplo 1. Ilustración de un vector en R c(1, 2, 3, 4, 5) ## [1] 1 2 3 4 5 # Ejemplo 2. Ilustración de un vector en R dentro de una variable y &lt;- c(6L, 7L, 8L, 9L, 10L) y ## [1] 6 7 8 9 10 En R, a diferencia de lo que pasa en otros lenguajes de programación, no existe una estructura de datos que haga referencia a los escalares11. Los escalares en R son entendidos como vectores de longitud 1. Este hecho, implica la siguiente regla del lenguaje. Regla: Escalares en R En R, a diferencia de otros lenguajes de programación, no existen datos de tipo escalar. Estos son considerados vectores de longitud 1. A continuación, se presentan algunos ejemplos en donde se ilustra el uso de los escalares en R como vectores de longitud 1. Ejemplo. Escalares como vectores en R # Ejemplo 1. Escalares en R 1L ## [1] 1 2.23 ## [1] 2.23 # Ejemplo 2. Escalares como vectores en R c(1L) ## [1] 1 c(2.23) ## [1] 2.23 # Ejemplo 3. Variables y escalares en R Var_1 &lt;- 1L Var_1 ## [1] 1 var_2 &lt;- c(1L) var_2 ## [1] 1 2.6.1.1 Tipos de vectores Los elementos que conforman un vector en R, como se mencionó en la regla anterior, deben ser del mismo tipo. Este hecho implica que, en este lenguaje podemos construir vectores los cuales, dependiendo del tipo de datos que contienen, pueden ser clasificados en una de cuatro categorías: lógicos, enteros, numéricos y de cadena o caracter. A continuación, se presenta una breve descripción así como algunos ejemplos de los diferentes tipos de vectores existentes en R. Lógicos Los vectores lógicos en R, como su nombre lo indica, están conformados por elementos de tipo lógico (TRUE o FALSE). A continuación, se presentan algunos ejemplos de vectores de tipo lógico en R. Ejemplo. Vectores lógicos en R # Ejemplo 1. Mi primer vector Lógico c(TRUE, FALSE, FALSE, TRUE) ## [1] TRUE FALSE FALSE TRUE # Ejemplo 2. Otro vector lógico en R c(TRUE, FALSE) ## [1] TRUE FALSE # Ejemplo 3. Un vector lógico dentro de una variable en R x &lt;- c(TRUE, FALSE, FALSE) x ## [1] TRUE FALSE FALSE Enteros Los vectores de tipo entero en R, como su nombre lo indica, están conformados por elementos de que se corresponden con los número enteros. A continuación, se presentan algunos ejemplos de vectores de tipo entero en R. Ejemplo. Vectores enteros en R # Ejemplo 1. Mi primer vector entero c(12L, 3L, 24L, 8L) ## [1] 12 3 24 8 # Ejemplo 2. Otro vector entero en R c(1L, 2L) ## [1] 1 2 # Ejemplo 3. Un vector entero dentro de una variable en R y &lt;- c(1L, -3L, 5L) y ## [1] 1 -3 5 Numéricos Los vectores de tipo numérico en R, como su nombre lo indica, están conformados por elementos de que se corresponden con los números reales. A continuación, se presentan algunos ejemplos de vectores de tipo numérico en R. Ejemplo. Vectores numéricos en R # Ejemplo 1. Mi primer vector numérico (real) c(12.10, 24.90, 4.99) ## [1] 12.10 24.90 4.99 # Ejemplo 2. Otro vector numérico en R c(1, 2.5, pi) ## [1] 1.000000 2.500000 3.141593 # Ejemplo 3. Un vector mumérico dentro de una variable en R z &lt;- c(2.3, -2.5, 7, 4) z ## [1] 2.3 -2.5 7.0 4.0 Cadena o caracter Los vectores de tipo cadena o caracter en R, como su nombre lo indica, están conformados por elementos en cuyo interior encontramos textos. A continuación, se presentan algunos ejemplos de vectores de tipo caracter en R. Ejemplo. Vectores cadena o caracter en R # Ejemplo 1. Mi primer vector de tipo caracter c(&quot;Lunes&quot;, &quot;Martes&quot;, &quot;Miércoles&quot;,&quot;Jueves&quot;, &quot;Viernes&quot;, &quot;Sábado&quot;,&quot;Domingo&quot;) ## [1] &quot;Lunes&quot; &quot;Martes&quot; &quot;Miércoles&quot; &quot;Jueves&quot; &quot;Viernes&quot; &quot;Sábado&quot; ## [7] &quot;Domingo&quot; # Ejemplo 2. Otro vector de tipo caracter c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Ejemplo 3. Un vector de tipo carcater dentro de una variable en R w &lt;- letters w ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 2.6.1.2 Coerción en vectores Los vectores en R, como se ha mencionado, deben contener elementos del mismo tipo. Para que esta condición se cumpla, el lenguaje aplica la siguiente regla al momento de disponer de vectores en cuyo interior conviven elementos de diversas tipologías12. Regla:Coerción de vectores en R R, al detectar la presencia de un vector con elementos de diversos tipos, convierte/coerciona la totalidad de los elementos del vector en una única tipología siguendo la siguiente jerarquía. caracter &gt; numérico &gt; entero &gt; lógico Es decir, en R, si existe un vector con elementos de tipo lógico y de tipo entero, el resultado es un vector con la totalidad de elementos de tipo entero (entero &gt; lógico). Si existe un vector con elementos de tipo lógico, entero y numérico, el resultado es un vector con la totalidad de elementos de tipo numérico o real (numérico &gt; entero &gt; lógico). Finalmente, si existe un vector con elementos de tipo lógico, entero, numérico y caracter o cadena, el resultado es un vector con la totalidad de elementos de tipo caracter (caracter &gt; numérico &gt; entero &gt; lógico). A continuación, se presentan algunos ejemplos de aplicación de la regla de coerción de elementos de un vector en R. Ejemplo. Coerción de elementos de un vector en R # Ejemplo 1. Vector con elementos enteros y lógicos c(TRUE, FALSE, 2L, -10L) ## [1] 1 0 2 -10 # Ejemplo 2. Vector con elementos lógicos, enteros y numéricos c(FALSE, 5L, 10.2) ## [1] 0.0 5.0 10.2 # Ejemplo 3. Vector con elementos lógicos, enteros, numéricos y de tipo caracter c(TRUE, -2L, 3.1415, &quot;Lunes&quot;) ## [1] &quot;TRUE&quot; &quot;-2&quot; &quot;3.1415&quot; &quot;Lunes&quot; # Ejemplo 4. Vector con elementos lógicos y de tipo caracter dentro de una variable m &lt;- c(TRUE, FALSE, &quot;Junio&quot;) m ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;Junio&quot; 2.6.1.3 ¿Cómo crear vectores rápidamente? Uno de las actividades más frecuentes a la hora de trabajar con R implica el uso, la creación y la manipulación de vectores. Por esta razón, este lenguaje ofrece algunas alternativas para la creación de vectores de una manera rápida. Entre las alternativas existentes, sobresalen las siguientes tres funciones útiles para la creación de diversos tipos de vectores en R. Función : La función :, permite la creación de una secuencia numérica que inicia en el número de la parte izquierda, se incrementa de uno en uno y finaliza en el valor de la parte derecha. Por ejemplo, la secuencia 1:20, inicia en el valor 1 y se incrementa de uno en uno hasta alcanzar el valor 20; de igual manera, la secuencia 10:15, inicia en el valor 10 y se incrementa de uno en uno hasta alcanzar el valor 15. A continuación, se presentan algunos ejemplos del uso de la función : en la creación de vectores en R. Ejemplo. Creación de vectores haciendo uso de la función `:` # Ejemplo 1. Secuencia ascendente c(1:20) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Ejemplo 2. Secuencia ascendente c(10:15) ## [1] 10 11 12 13 14 15 # Ejemplo 3. Secuencia descendente c(10:1) ## [1] 10 9 8 7 6 5 4 3 2 1 # Ejemplo 4. Secuencias dentro de variables n &lt;- c(1:5) n ## [1] 1 2 3 4 5 Función seq() La función seq(), permite la creación de un vector con una secuencia de datos. No obstante, esta función, a diferencia de la función :, permite que el usuario defina el incremento o múltiplo que será tenido en cuenta dentro de la secuencia. Por ejemplo, la instrucción seq(from = 0, to = 30, by = 2), permite la creación de una secuencia de números que inicia en 1 (from), va hasta 30 (to) y se incrementa de dos en dos (by). En la función seq(from = 0, to = 30, by = 2), las palabras from, to y by, se conocen con el nombre de parámetros de la función seq(). Los parámetros de una función en R, como se verá en la sección de funciones, pueden ser o no incluidos13 al momento de invocar una función dependiendo del orden en el que estos fueron definidos por dicha función. Por el momento, como se corrobora en los ejemplos que se presentan a continuación, la instrucción seq(from = 0, to = 30, by = 2) es equivalente en R a la instrucción seq(0, 30, 2), sin el nombre de los parámetros. Ejemplo. Creación de vectores haciendo uso de la función `seq()` # Ejemplo 1. Secuencia ascendente seq(from = 0, to = 30, by = 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 seq(0, 30, 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 # Ejemplo 2. Secuencia descendente seq(from = 20, to = 0, by = -5) ## [1] 20 15 10 5 0 seq(20, 0, -5) ## [1] 20 15 10 5 0 # Ejemplo 3. Secuencias dentro de variables p &lt;- seq(1, 10, 2) p ## [1] 1 3 5 7 9 Función rep() La función rep(), permite la creación de un vector cuyos elementos se repiten un número determinado de veces. Por ejemplo, la instrucción rep(1, times = 5), crea un vector con el número 1 repetido 5 veces (times). De igual modo, la instrucción rep(1:3, times = 2), crea un vector con la secuencia de números del 1 al 3 repetida dos veces. La funciónrep(), además de permitir la creación de vectores cuyos elementos se repiten un número determinado de veces times, dispone de un parámetro llamado each a través del cual es posible definir cuántas veces deseamos que un elemento dentro de un vector se repita por sí mismo. Por ejemplo, la instrucción rep(1:2, times = 2, each = 4), construye un vector en donde los números definidos en la secuencia 1:2 se repite cada uno cuatro veces each = 4 y luego, el bloque con los elementos resultantes, se duplica times = 2. A continuación, se presentan algunos ejemplos de creación de vectores haciendo uso de la función rep(). Ejemplo. Creación de vectores haciendo uso de la función `rep()` # Ejemplo 1. Repeticiones simples (con times) rep(1, times = 5) ## [1] 1 1 1 1 1 rep(1, 5) ## [1] 1 1 1 1 1 rep(1:3, times = 2) ## [1] 1 2 3 1 2 3 rep(1:3, 2) ## [1] 1 2 3 1 2 3 # Ejemplo 2. Repeticiones simples (con each) rep(1, each = 5) ## [1] 1 1 1 1 1 rep(c(1:3), each = 2) ## [1] 1 1 2 2 3 3 # Ejemplo 3. Repeticiones compuestas con times y each rep(1, times = 2, each = 4) ## [1] 1 1 1 1 1 1 1 1 rep(1:2, times = 2, each = 4) ## [1] 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 # Ejemplo 4. Repeticiones compuestas con times y each rep(c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), times = 3, each = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; # Ejemplo 5. Repeticiones compuestas con times y each rep(c(TRUE, FALSE), times = 2, each = 3) ## [1] TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE # Ejemplo 6. Repeticiones dentro de variables s &lt;- rep(10, 5) s ## [1] 10 10 10 10 10 2.6.1.4 Operaciones con vectores En R, es posible implementar operaciones entre vectores las cuales, al igual que el escenario de tipos de datos presentados en las secciones 2.3 y 2.5, pueden ser de dos clases: aritméticas y lógicas. 2.6.1.4.1 Operaciones aritméticas con vectores Adición, sustracción, multiplicación y división Al inicio de este capítulo, en la sección de operaciones aritméticas, se presentó la capacidad que tiene R para la evaluación de operaciones entre las que se destacan, desde luego, las basadas en los operadores aritméticos simples (+, -, *, /). En R, es posible implementar estas y otras operaciones entre vectores y para ello, este lenguaje, se vale de la siguiente regla. Regla: Operaciones aritméticas simples entre vectores En R, es posible implementar operaciones simples entre vectores; es decir, la suma, la resta, la multiplicación y la división. Al implementar estas operaciones, el lenguaje exige que los vectores involucrados tengan igual longitud -misma cantidad de elementos- y que estos sean del mismo tipo. En la figura de abajo, se ilustra una suma entre vectores asociados a dos variables exam_grades y homework_grades cuyo resultado es almacenado en una variable llamada sum_grades. Al observar la conformación de los vectores involucrados en la suma observamos que estos, además de tener elementos de una misma tipología, tienen igual longitud; es decir, cumplen con los requisitos exigidos para el desarrollo de esta operación. Ejemplo suma con vectores A continuación, se evalúa en R la operación entre vectores propuesta en la anterior imagen. Así mismo, en el ejemplo 2, se evalúa una operación entre vectores14 la cual incluye tres de los operadores aritméticos simples (+, - y /). Ejemplo. Ilustración de operaciones entre vectores en R # Ejemplo 1. Suma de vectores en R haciendo uso de variables exam_grades &lt;- c(92, 90, 84, 95, 77, 92, 85) homework_grades &lt;- c(87, 81, 95, 86, 85, 90, 88) sum_grades &lt;- exam_grades + homework_grades sum_grades ## [1] 179 171 179 181 162 182 173 # Ejemplo 2. Operaciones entre vectores (suma, resta y división) v1 &lt;- c(1:5) v2 &lt;- seq(from = 5, to = 1, by = -1) v3 &lt;- rep(1, times = 5) v4 &lt;- c(6, 6, 6, 6, 6) v5 &lt;- rep(2, 5) v6 &lt;- v4 / v5 total &lt;- v1 + v2 + v3 - v6 promedio &lt;- total / 4 promedio ## [1] 1 1 1 1 1 Reciclaje de elementos en operaciones aritméticas con vectores Las operaciones entre vectores, como se presentó en la anterior regla, exige que estos tengan igual longitud15; es decir, la misma cantidad de elementos. En este sentido, al observar el siguiente ejemplo que contiene una suma entre vectores de diferentes longitudes, la pregunta que surge es ¿qué hace R ante este escenario? y la respuesta es que este no genera un error; es decir, el lenguaje genera un resultado ante este escenario y para ello se vale de una regla conocida con el nombre de reciclaje de elementos. Regla: Reciclaje de elementos en operaciones entre vectores en R En una operación aritmética entre vectores de diferentes longitudes, R iguala las longitudes de los vectores con longitud menor. Para ello, recicla/rellena las posiciones faltantes partiendo del primer elemento que conforma cada uno de los vectores -las veces que sea necesario-, hasta el elemento que permita igualar la cantidad de elementos que contiene el vector de mayor longitud involucrado en la operación. Al aplicar la regla de reciclaje de elementos al ejemplo antes expuesto, como se ilustra en la siguiente imagen y se evalúa en la parte baja, el vector de menor longitud (variable homework_grades con dos elementos) recicla los elementos disponibles partiendo del primero (87) y así sucesivamente hasta alcanzar la misma cantidad del vector de mayor longitud involucrado dentro de la suma de vectores propuesta (variable exam_grades). Reciclaje de elementos en operaciones con vectores en R Ejemplo. Aplicación de la regla de reciclaje a operaciones entre vectores - caso suma # Ejemplo. Reciclaje en operaciones entre vectores - caso suma v1 &lt;- c(92, 90, 84, 95, 77, 92, 85) v2 &lt;- c(87, 81) suma &lt;- v1 + v2 ## Warning in v1 + v2: longitud de objeto mayor no es múltiplo de la longitud de ## uno menor suma ## [1] 179 171 171 176 164 173 172 Dado que la regla de reciclaje puede inducir a importantes errores para aquellos usuarios que desconozcan la forma como este lenguaje implementa operaciones entre vectores con diferentes longitudes, R, como se observa en los resultados del ejemplo anterior, genera un mensaje de alerta en la que se advierte sobre la presencia de vectores con longitudes disímiles en la operación evaluada. 2.6.1.4.2 Operaciones lógicas con vectores En R, como se presenta en la siguiente regla, es posible implementar operaciones de tipo lógico las cuales hacen uso de operadores de tipo relacional o lógico y cuyo resultado en un vector conformado por elementos de tipo lógico (TRUE o FALSE). Regla: Operaciones lógicas entre vectores En R, es posible implementar operaciones lógicas entre vectores de igual longitud haciendo uso de los operadores relacionales o de una combinación entre estos y los operadores lógicos. El resultado de una operación lógica entre vectores es un vector de tipo lógico. Operaciones lógicas con vectores - operadores relacionales Las operaciones lógicas entre vectores, como se acaba de definir, pueden hacer uso de los operadores de tipo relacional &lt;, &gt;, &lt;=, &gt;=, == y !=. Por ejemplo, si deseamos conocer las posiciones en las que se ubican números negativos en el vector Vect_1 &lt;- c(-2:4, 1, 2), implicaría en R la creación de la siguiente línea de código Vect_1 &lt; 0; de la misma manera, si deseamos conocer las posiciones en las que se ubica el número 1, basta con implementar dentro de este lenguaje la instrucción Vect_1 == 1. A continuación, en el ejemplo 1, se evalúan en R las operaciones lógicas discutidas en el párrafo anterior. Así mismo, en el ejemplo 2, se presentan otros ejemplos de operaciones lógicas con vectores haciendo uso de operadores relacionales. Ejemplo. Operaciones lógicas con vectores haciendo uso de operadores relacionales # Ejemplo 1. Operaciones lógicas con vectores haciendo uso de operadores relacionales # Creación y evaluación del vector Vect_1 &lt;- c(-2:4, 1, 2) Vect_1 ## [1] -2 -1 0 1 2 3 4 1 2 # Números negativos Vect_1 &lt; 0 ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # Posiciones en las que se ubica el número 1 Vect_1 == 1 ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE # Ejemplo 2. Operaciones lógicas con vectores haciendo uso de operadores relacionales # Creación y evaluación del vector Vect_2 &lt;- c(10, 20, 15, 15, 20, 25, 30) Vect_2 ## [1] 10 20 15 15 20 25 30 # Posiciones en las que no se ubica el número 15 Vect_2 != 15 ## [1] TRUE TRUE FALSE FALSE TRUE TRUE TRUE # Posiciones con números mayores o iguales a 20 Vect_2 &gt;= 20 ## [1] FALSE TRUE FALSE FALSE TRUE TRUE TRUE # Posiciones con números mayores a 20 Vect_2 &gt; 20 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE # Posiciones con números menores a 10 Vect_2 &lt; 10 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE Operaciones lógicas con vectores - operadores lógicos En R, además de implementar operaciones lógicas con vectores haciendo uso de operadores relacionales, es posible implementar operaciones que involucran a estos tipos de operadores y a los tres de naturaleza lógica (&amp;, | y !) que fueron discutidos en la sección 2.5. La implementación de operaciones lógicas entre vectores en donde se involucra tanto los operadores de tipo relacional como los de tipo lógico, implica a su vez el uso de dos o más vectores. Por ejemplo, si contamos con los vectores x &lt;- c(-3, 4, -5, 0, 1) e y &lt;- c(-10, 2, 0, 1, 1) y deseamos conocer las posiciones en las que ambos vectores disponen de números negativos, implica en R la construcción de la instrucción x &lt; 0 &amp; y &lt; 016. A continuación, en el ejemplo 1, se evalúan en R las operación lógica discutida en el párrafo anterior. Así mismo, en el ejemplo 2, se presentan otros ejemplos de operaciones lógicas con vectores haciendo uso de operadores relacionales y lógicos. Ejemplo. Operaciones lógicas con vectores haciendo uso de operadores relacionales y lógicos # Ejemplo 1. Operaciones lógicas con vectores haciendo uso de operadores relacionales y lógicos # Creación y evaluación de los vectores x &lt;- c(-3, 4, -5, 0, 1) x ## [1] -3 4 -5 0 1 y &lt;- c(-10, 2, 0, 1, 1) y ## [1] -10 2 0 1 1 # Posiciones negativas en los dos vectores x &lt; 0 &amp; y &lt; 0 ## [1] TRUE FALSE FALSE FALSE FALSE # Ejemplo 2. Operaciones lógicas con vectores haciendo uso de operadores relacionales y lógicos # Creación y evaluación de los vectores m &lt;- c(-3, 4, -5, 0, 1) m ## [1] -3 4 -5 0 1 n &lt;- c(-10, 2, 0, 1, 1) n ## [1] -10 2 0 1 1 # Posiciones positivas en los dos vectores x &gt; 0 &amp; y &gt; 0 ## [1] FALSE TRUE FALSE FALSE TRUE # Al menos una posición positiva en los dos vectores x &gt; 0 | y &gt; 0 ## [1] FALSE TRUE FALSE TRUE TRUE # Al menos una posición negativa o cero en los dos vectores !(x &gt; 0 &amp; y &gt; 0) ## [1] TRUE FALSE TRUE TRUE FALSE En la regla sobre operaciones lógicas entre vectores se aludió a la necesiad de que los vectores involucrados en estas operaciones tengan la misma longitud; es decir, igual cantidad de elementos. Pero, que pasa si por ejemplo, nos enfrentamos a operaciones en donde esta condición no se cumpla. La respuesta del lenguaje R ante este escenario es la aplicación de la regla de reciclaje de elementos resultantes en los vectores lógicos de menor longitud con el fin de igualar su contenido al de mayor longitud y poder implementar la operación deseada. Esta característica del lenguaje, se presenta en la siguiente regla. Regla: Reciclaje de elementos en operaciones lógicas entre vectores en R En una operación lógica entre vectores de diferente longitud R iguala, las longitudes de los vectores de menor tamaño17, con la longitud del vector de mayor tamaño involucrado en la operación. A continuación, se presenta un ejemplo de la aplicación de la regla de reciclaje de elementos en R en operaciones lógicas entre vectores. Ejemplo. Aplicación regla de reciclaje de elementos en operaciones lógicas entre vectores # Ejemplo. Operaciones lógicas con vectores haciendo uso de operadores relacionales y lógicos # Creación y evaluación vector de longitud 5 x &lt;- c(-3, 4, -5, 0, 1) x ## [1] -3 4 -5 0 1 # Creación y evaluación vector de longitud 3 y &lt;- c(-10, 2, 0) y ## [1] -10 2 0 # Operación lógica con operador relacional vector x x &lt; 0 ## [1] TRUE FALSE TRUE FALSE FALSE # Operación lógica con operador relacional vector y y &lt; 0 ## [1] TRUE FALSE FALSE # Operación lógica con operadores relacionales y lógicos # vectores x e y de diferente longitud # aplicación de la regla de reciclaje x &gt; 0 &amp; y &gt; 0 ## Warning in x &gt; 0 &amp; y &gt; 0: longitud de objeto mayor no es múltiplo de la longitud ## de uno menor ## [1] FALSE TRUE FALSE FALSE TRUE Dado que la regla de reciclaje puede inducir a importantes errores para aquellos usuarios que desconozcan la forma como este lenguaje implementa operaciones lógicas entre vectores con diferentes longitudes, R, como se observa en los resultados del ejemplo anterior, genera un mensaje de alerta (Warning) en el que se advierte sobre la presencia de vectores con longitudes disímiles en la operación evaluada. 2.6.1.5 Indexación/subconjuntos de vectores Una de las acciones más frecuentes a la hora de trabajar con vectores o cualquier otra estructura de datos en R, como veremos en adelante, es la orientada a la extracción o indexación de un subconjunto de sus elementos. Para ello, hay que tener en cuenta que R es un lenguaje de programación indexado en 1; es decir, para el caso del trabajo con vectores, al primer elemento se le asigna la posición 1. Para extraer elementos de un vector, como se muestra en la figura de abajo, hay que comprender que cada uno de los elementos que conforman un vector tiene asociada una posición conocida como indíce. En el vector ilustrado en la figura, al número 92 le corresponde la posición 1, al 87 la posición 2 y al 85 la posición 3. Gráfico con ilustración de índices dentro de vectores Para extraer elementos o subconjuntos de un vector debemos tener en cuenta la siguiente regla asociada a este lenguaje. Regla: Subconjuntos de vectores en R Para extraer elementos de un vector en R se usan corchetes [ ] Por ejemplo, si deseamos extraer el elemento 85 contenido en el vector ilustrado en la figura anterior bastaría con indicar, entre corchetes, la posición dentro del vector en la cual se encuentra ubicado dicho elemento; es decir, la tercera o 3. Una vez identificada la posición de dicho elemento, se procede a generar la instrucción dentro de R que nos permita extraer el o los elementos deseados la cual, para el caso de nuestro ejemplo, es c(92, 87, 85)[3]. En R, no es común que la indexación o creación de subconjuntos de elementos de un vector o de otra estructura de datos se haga directamente sobre el vector -como se acaba de presentar-; lo común, es que esta se dé sobre el mombre de una variable que contiene los elementos de dicho vector. A continuación, se extrae el elemento 85 del vector de nuestro ejemplo haciendo uso de variables cuyo resultado, como se mostrará, es equivalente al haber aplicado la extracción sobre el vector puro u original. Ejemplo. Extracción de elementos de un vector # Ejemplo 1. Extracción directa - no recomendada. c(92, 87, 85)[3] ## [1] 85 # Ejemplo 2. Extracción haciendo uso de nombres de vectores (variables) - recomendada vector_1 &lt;- c(92, 87, 85) vector_1[3] ## [1] 85 En R y en los entornos de análisis de datos, más que extraer un elemento de un vector, como se acaba de ilustrar en el ejemplo propuesto, el objetivo es obtener un subconjunto de elementos contenidos en ciertas posiciones que cumplen algunas características requeridas por los usuarios. Para ello, se acude al uso de vectores que contienen las posiciones que se requieren extraer. Este hecho, implica la siguiente regla asociada a las posibilidades existentes en este lenguaje para extraer elementos de un vector a partir de las posiciones contenidas en otro vector. Regla: Subconjuntos de vectores en R En R, existen seis (6) posibilidades para extraer elementos de un vector: vectores con enteros positivos, vectores con enteros negativos, vectores lógicos, vectores de tipo caracter, ninguno (nothing) y cero (zero)18. A continuación, se presenta con mayor detalle, tres de las cuatro opciones que serán tenidas en cuenta en este documento para la extracción de elementos de un vector19. Vectores con enteros positivos La extracción de elementos a partir de vectores conformados por enteros positivos retorna los elementos disponibles en las posiciones especificadas. Por ejemplo, si se desea obtener los valores contenidos en las posiciones 1, 3 y 5 del vector Vect_1 &lt;- c(15, 17, 12, 45, 13, 18) haciendo uso de enteros positivos, la instrucción en R sería Vect_1[c(1, 3, 5)]. A continuación, en el ejemplo 1, se presenta la implementación de esta instrucción en R; así mismo, en el ejemplo 2, se presentan otros subconjuntos de un vector en R haciendo uso de vectores conformados por enteros positivos. Invitamos al lector a analizar y entender la filosofía existente atrás de estos ejemplos. Ejemplo. Extracción de elementos de un vector con entero positivos # Ejemplo 1. Selección de elementos de un vector en R haciendo uso de enteros positivos Vect_1 &lt;- c(15, 17, 12, 45, 13, 18) Vect_1[c(1,3,5)] ## [1] 15 12 13 # Ejemplo 2. Selección de elementos de un vector en R haciendo uso de enteros positivos #Creación y visualización del vector Vect_2 con las 26 letras mayúsculas del alfabeto romano Vect_2 &lt;- LETTERS Vect_2 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # Selecionar las primeras 5 letras mayúsculas del alfabeto romano- alternativa 1 Vect_2[c(1, 2, 3, 4, 5)] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; # Selecionar las primeras 5 letras mayúsculas del alfabeto romano- alternativa 2 Vect_2[c(1:5)] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; # Selecionar las primeras 5 letras mayúsculas del alfabeto romano- alternativa 3 Vect_2[1:5] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; # Selecionr las primeras 5 letras mayúsculas del alfabeto romano- alternativa 4 Vect_2[seq(from = 1, to = 5, by = 1)] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; # Selecionar la primera y la última letra del alfabeto romano Vect_2[c(1, 26)] ## [1] &quot;A&quot; &quot;Z&quot; # Selecionar la vocales del alfabeto romano Vect_2[c(1L, 5L, 9L, 15L, 21L)] ## [1] &quot;A&quot; &quot;E&quot; &quot;I&quot; &quot;O&quot; &quot;U&quot; # Selecionar la letra c del alfabeto romano 5 veces Vect_2[rep(3, times = 5)] ## [1] &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; # Seleccionar las letras del alfabero romano ubicadas en las posiciones 1, 4, 7, 1, ... (de tres en tres) Vect_2[seq(1, 26, 3)] ## [1] &quot;A&quot; &quot;D&quot; &quot;G&quot; &quot;J&quot; &quot;M&quot; &quot;P&quot; &quot;S&quot; &quot;V&quot; &quot;Y&quot; # Seleccionar últimas tres letras del alfabero romano y guardar el resultado en una variable (Vect_3) Vect_3 &lt;- Vect_2[c(24:26)] Vect_3 ## [1] &quot;X&quot; &quot;Y&quot; &quot;Z&quot; Vectores con enteros negativos La extracción de elementos de un vector a partir de vectores conformados por enteros negativos excluye los elementos en las posiciones especificadas. Por ejemplo, si se desea obtener un vector que excluya las posiciones 1, 3 y 5 del vector Vect_4 &lt;- c(15, 17, 12, 45, 13, 18) haciendo uso de enteros negativos, la instrucción en R sería Vect_4[c(-1, -3, -5)]. A continuación, en el ejemplo 1, se presenta la implementación de esta instrucción en R; así mismo, en el ejemplo 2, se presentan otros subconjuntos de un vector en R haciendo uso de vectores conformados por enteros negativos. Invitamos al lector a analizar y entender la filosofía existente atrás de estos ejemplos. Ejemplo. Extracción de elementos de un vector con enteros negativos # Ejemplo 1. Selección de elementos de un vector en R haciendo uso de enteros negativos Vect_4 &lt;- c(15, 17, 12, 45, 13, 18) Vect_4[c(-1, -3, -5)] ## [1] 17 45 18 # Ejemplo 2. Selección de elementos de un vector en R haciendo uso de enteros negativos0/ # Crear un vector de tipo numérico - primeros 10 números primos Vect_5 &lt;- c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29) # Excluir los primeros cinco números primos - alternativa 1 Vect_5[c(-1, -2, -3, -4, -5)] ## [1] 13 17 19 23 29 # Excluir los primeros cinco números primos - alternativa 2 Vect_5[c(-1:-5)] ## [1] 13 17 19 23 29 # Excluir los primeros cinco números primos - alternativa 3 Vect_5[-c(1:5)] ## [1] 13 17 19 23 29 # Excluir los primeros cinco números primos - alternativa 4 Vect_5[seq(from = -1, to = -5, by = -1)] ## [1] 13 17 19 23 29 # Excluir el primer número primo Vect_5[c(-1)] ## [1] 3 5 7 11 13 17 19 23 29 # Excluir el octavo, el noveno y el décimo número primo Vect_5[c(-8L:-10L)] ## [1] 2 3 5 7 11 13 17 # Excluir los primeros siete números primos y guardar el resultado en una variable (Vec_6) Vect_6 &lt;- Vect_5[-c(1:7)] Vect_6 ## [1] 19 23 29 Vectores lógicos La extracción de elementos de un vector a partir de vectores conformados por elementos lógicos permite la selección de los elementos donde el valor lógico correspondiente es verdadero (TRUE). Esta es probablemente la alternativa más útil para seleccionar subconjuntos de vectores en R en razón a que, como veremos a continuación, permite el uso de expresiones lógicas. La extracción de elementos de un vector a partir del uso de vectores conformados por elementos lógicos, puede implementarse de manera directa -haciendo uso del vector lógico requerido- o a través de un vector lógico derivado de la evaluación de una operación lógica. Filosóficamente, la extracción de elmentos de un vector haciendo uso d evectores de tipo lógico, presentan la siguiente estructura. Nombre_vector[c(LOGICO)] En la estructura anterior, el Nombre_vector hace referencia al vector del cual deseamos extraer algunos elementos; el operador [ ], como se definió previamente, nos permite extraer elementos de un vector en R y, finalmente, el c(LOGICO) contiene un vector lógico en donde se definen las posiciones que contienen los elementos que serán extraidos. 3.1 Vectores lógicos - manera directa La extracción de elementos de un vector a través del uso de vectores lógicos generados de manera directa exige que el usuario construya de manera manual, el vector lógico en cuyo interior se define, a través de datos de tipo TRUE, las posiciones que se desean extraer. Por ejemplo, si deseamos extraer la primera y la última posición del vector Vect_1 &lt;- c(1:5) haciendo uso de un vector lógico construido de manera directa, debemos implementar en R la instrucción Vect_1[c(TRUE, FALSE, FALSE, FALSE, TRUE)]. A continuación, en el ejemplo 1, se presenta la implementación de esta instrucción en R; así mismo, en el ejemplo 2, se presentan otros subconjuntos de elementos de un vector en R haciendo uso de vectores conformados por datos de tipo lógico. Ejemplo. Extracción de elementos de un vector con vectores lógicos # Ejemplo 1. Extracción de elementos con vectores lógicos directos # Creación y evaluación del vector Vect_1 &lt;- c(1:5) Vect_1 ## [1] 1 2 3 4 5 # Extracción del primero y del último elemento Vect_1[c(TRUE, FALSE, FALSE, FALSE, TRUE)] ## [1] 1 5 # Ejemplo 2. Extracción de elementos con vectores lógicos directos # Creación y evaluación del vector Vect_2 &lt;- seq(0, 6, 2) Vect_2 ## [1] 0 2 4 6 # Extracción de los primeros dos elementos Vect_2[c(TRUE, TRUE, FALSE, FALSE)] ## [1] 0 2 # Extracción del último elemento Vect_2[c(FALSE, FALSE, FALSE, TRUE)] ## [1] 6 La extracción de elementos de un vector en R haciendo uso de vectores de tipo lógico construidos de manera manual, implica que el vector lógico debe tener la misma cantidad de elementos que el vector de donde se desean extraer los elementos de interés. En el caso de la presencia de un vector lógico de menor longitud, este recicla sus elementos con el fin de garantizarla igualdad de elementos entre los vectores involucrados en la selección20. Por ejemplo, si deseamos extraer los números impares contenidos en el vector Vect_2 &lt;- c(1:50) haciendo uso de un vector lógico construido de manera manual, resulta muy engorroso el proceso de construcción del vector lógico que nos garantice esta selección en razón a que este está compuesto por 50 elementos. En esta situación, resulta útil la construcción de un vector lógico de menor longitud y obligar al lenguaje a que aplique la regla de reciclaje al mismo para obtener el resultado deseado. A continuación, se presenta el desarrollo del ejemplo contenido en el párrafo anterior así como otros ejemplos en donde resulta útil la construcción de vectores lógicos de menor tamaño para extraer elementos de vectores conformados por una alta cantidad de elementos. Ejemplo. Extracción de elementos con vectores lógicos - regla de reciclaje # Aplicación regla de reciclaje para extracción de elementos con vectores lógicos # Creación y evaluación del vector Vect_2 &lt;- c(1:50) Vect_2 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Ejemplo 1. Extracción de los números impares Vect_2[c(TRUE, FALSE)] ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 # Ejemplo 2. Extracción de los números pares Vect_2[c(FALSE, TRUE)] ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 # Ejemplo 2. Extracción de los múltiplos de 5 Vect_2[c(FALSE, FALSE, FALSE, FALSE, TRUE)] ## [1] 5 10 15 20 25 30 35 40 45 50 3.2 Vectores lógicos - operaciones lógicas La extración de elementos de un vector haciendo uso de vectores lógicos directos o contruidos de manera manual, es una actividad poco frecuente a la hora de gestionar vectores en R. En este lenguaje, el uso de vectores lógicos para la extracción de elementos es ampliamente usado cuando estos se disponen o construyen a partir del resultado de una operación lógica en la que se involucran operadores relacionales (&lt;, &gt;, &lt;=, &gt;=, == y !=), operadores lógicos (&amp;, | y !) o una combinación de ambos. Por ejemplo, si deseamos extraer los números negativos del vector Vect_3 &lt;- c(-5, 10), bastaría implementar en R la instrucción Vect_3[Vect_3 &lt; 0]. En la instrucción anterior, la operación aritmética contenida dentro de los corchetes Vect_3 &lt; 0, arroja un vector lógico con valores TRUE para las posiciones (index) del vector Vect_3 en donde existen números negativos y FALSE en donde existen ceros o números positivos; paso seguido, el software procede a extraer los elementos de interés del vector en cuestión haciendo uso del vector lógico resultante de la operación lógica. A continuación, se presenta en R el resultado del ejercicio ilustrado en el párrafo anterior así como otros ejemplos en donde se hace uso de operaciones lógicas con operadores relacionales y lógicos para la extracción de los elementos contenidos dentro de un vector. Invitamos al lector a analizar y reflexionar sobre los pasos que implementa R al momento de extraer elementos de un vector a partir de operaciones lógicas y, en especial, a través de aquellas que combinan operadores relacionales y lógicos (ver ejemplos 4, 5 y 6). Ejemplo. Extracción de elementos con vectores lógicos derivados de operaciones lógicas # Extracción de elementos con vectores lógicos derivados de operaciones lógicas # Creación y evaluación del vector Vect_3 &lt;- c(-5:10) Vect_3 ## [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 # Ejemplo 1. Extracción de los números negativos - operadores relacionales Vect_3[Vect_3 &lt; 0] ## [1] -5 -4 -3 -2 -1 # Ejemplo 2. Extracción de los números positivos - operadores relacionales Vect_3[Vect_3 &gt; 0] ## [1] 1 2 3 4 5 6 7 8 9 10 # Ejemplo 3. Extracción de los ceros - operadores relacionales Vect_3[Vect_3 == 0] ## [1] 0 # Ejemplo 4. Extracción de los números negativos o de los mayores o iguales a 5 # operadores relacionales y lógicos Vect_3[Vect_3 &lt; 0 | Vect_3 &gt;= 5] ## [1] -5 -4 -3 -2 -1 5 6 7 8 9 10 # Ejemplo 5. Extracción de los números en el intervalo [0, 5) # Alternativa 1 Vect_3[!(Vect_3 &lt; 0 | Vect_3 &gt;= 5)] ## [1] 0 1 2 3 4 # Ejemplo 6. Extracción de los números en el intervalo [0, 5) # Alternativa 2 # Guardar y evaluar resultados a partir de una variable Vect_4 &lt;- Vect_3[Vect_3 &lt; 5 &amp; Vect_3 &gt;= 0] Vect_4 ## [1] 0 1 2 3 4 2.6.1.6 Nombres de elementos en vectores Los vectores en R, además de ser construidos a partir del comando c(), están compuestos por elementos los cuales, como se presentó en la sección de tipos de vectores, definen la tipolología que los representa: lógicos, enteros, numéricos y cadena o caracter. Los vectores, además de las características antes ilustradas, pueden contener nombres que identifiquen a cada uno de sus elementos. Es decir, además de contar con un número indice que los identifica, estos pueden contener nombres asociados a dichos indíces. En la figura que se presenta a continuación, se ilustra la filosofía a la hora de asignar nombres a los elementos que conforman un vector. Filosofia nombre vectores En R, existen 2 formas de asignar nombres a vectores: al momento de crear vectores o cuando estos están creados. A continuación, se presentan en detalle estas dos formas de asignación de nombres. Asignación de nombres a vectores - al crear el vector La asignación de nombres a los elementos de un vector en el momento en el que estos son creados se da a través del operador =. Este operador, inermedia entre el nombre y el valor que acompaña a cada uno de los elementos de un vector. Por ejemplo, el vector c(a = 5, b = 6, c = 7) está conformado por tres elementos en donde el nombre que representa al elemento 1 es la a, el que representa el elemento 2 es la b y el que representa al elemento 3 es la c. A continuación, se presenta este y otros ejemplos de asignación directa de nombres a los elementos de vectores en R. Ejemplo. Asignación a nombres de elementos de vectores en R - al crear vectores # Ejemplo 1. Nombres de elementos en vectores c(a = 5, b = 6, c = 7) ## a b c ## 5 6 7 # Ejemplo 2. Nombres de elementos en vectores c(x = TRUE, y = FALSE, z = TRUE, w = TRUE) ## x y z w ## TRUE FALSE TRUE TRUE # Ejemplo 3. Nombres de elementos en vectores haciendo uso de variables Var_2 &lt;- c(Nombre1 = &#39;a&#39;, Nombre2 = &#39;b&#39;, Nombre3 = &#39;c&#39;) Var_2 ## Nombre1 Nombre2 Nombre3 ## &quot;a&quot; &quot;b&quot; &quot;c&quot; Asignación de nombres a vectores - cuando el vector está creado La asignación de nombres a elementos de vectores en R en su momento de creación, en la excepción y no la regla. Lo norma, en este lenguaje, es que la asignación de nombres se dé una vez estos se han creado. Para ello, debemos acudir a una combinación entre una función disponible en R conocida como names() y un vector de tipo caracter con los nombres que serán asignados a los elementos de un vector dado. A continuación, se presentan dos ejemplos con la asignación de nombres de manera indirecta en R; es decir, cuando el vector ya se encuentra creado. # Ejemplo 1. Nombres de elementos en vectores vector1 &lt;- c(1:5) Nombres1 &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;) names(vector1) &lt;- Nombres1 vector1 ## a b c d e ## 1 2 3 4 5 # Ejemplo 2. Nombres de elementos en vectores vector2 &lt;- seq(from = 1, to = 10, by = 1) Nombres2 &lt;- letters[c(1:10)] names(vector2) &lt;- Nombres2 vector2 ## a b c d e f g h i j ## 1 2 3 4 5 6 7 8 9 10 En el primero de los ejemplos, en su primera línea de código, se crea un vector numérico c(1:5) y su contenido es almacenado en una variable llamada vector1. En la segunda línea de código, se crea un vector de tipo caracter c('a', 'b', 'c', 'd', 'e') con los nombres que tendrán los elementos del vector previamente creado y su contenido se guarda dentro de la variable Nombres1. En la tercera línea de código del ejemplo 1, se hace uso de la función names() para indicarle que a los elementos del vector1 se le asignen los nombres contenidos en el vector caracter Nombres1. Por último, en la línea cuatro del código, verificamos que el vector 1 cuenta con los nombres asignados a cada uno de sus elementos. Invitamos al lector a analizar y estudiar lo que hace R en el proceso de creación del nombre de los elementos del vector que hace parte del ejemplo 2. Finalmente, si deseamos conocer en R los nombres de los elementos de un vector, podemos hacerlo a través de la misma función empleada para su asignación; es decir, names(). Por ejemplo, si aplicamos la instrucción names(vector1) al vector resultantes del desarrollo del ejemplo 1, el lenguaje nos retorna los nombres de los elementos que hacen parte de este vector. Indexación de vectores a partir de nombres de elementos En la sección de Indexación/subconjuntos de vectores, se definió que en R existen 6 posibilidades para extraer elementos de un vector. De estas, se anunció que en este documento se ilustrarían 4 de estas posibilidades y se avanzó en tres de ellas: extracción de elementos a partir de vectores con enteros positivos, vectores con enteros negativos y vectores lógicos. A continuación, se presenta la cuarta y última alternativa para la selección de elementos de un vector la cual, como se verá, implica el uso de vectores de tipo cadena o caracter conformados por los nombres de los elementos de un vector. La extracción de elementos a partir de vectores conformados por vectores de tipo cadena o caracter retorna los elementos disponibles en las posiciones de un vector según sus nombres. Por ejemplo, si deseamos extraer la primera y la última posición del vector Var_1 &lt;- c(a = 1, b = 2, c = 3, d = 4, e = 5) a partir de los nombres de estos elementos, basta con implementar en R la línea de comando Var_1[c('a', 'e')]. En esta línea de comando, el operador (corchete) [] indica que estamos interesados en extraer un subconjunto de elementos contenidos en el vector Var_1 y el vector c('a', 'e') indica que los elementos que deseamos extraer son aquellos cuyos nombres son a y e; es decir, los ubicados en la primera y la última posición del vector Var_1. A continuación, en el ejemplo, se presenta el desarrollo de la anterior instrucción y de otros subconjuntos de vectores en R extraídos a partir de vectores de tipo caracter con los nombres de sus elementos. # Ejemplo 1. Extracción del primero y del último elemento Var_1 &lt;- c(a = 1, b = 2, c = 3, d = 4, e = 5) Var_1[c(&#39;a&#39;, &#39;e&#39;)] ## a e ## 1 5 # Ejemplo 2. Extracción de los elementos 2 y 3 Var_1[c(&#39;b&#39;, &#39;c&#39;)] ## b c ## 2 3 # Ejemplo 3. Extracción de los últimos dos elementos y guardar el resultado en una variable Var_2 &lt;- Var_1[c(&#39;d&#39;, &#39;e&#39;)] Var_2 ## d e ## 4 5 # Ejemplo 4. Extracción del primer elemento 5 veces Var_1[rep(&#39;a&#39;, 5)] ## a a a a a ## 1 1 1 1 1 2.6.2 Matrices La segunda estructura de datos empleda por R son las matrices. Estas, como se ilustra en la siguiente imagen, son estructuras de tipo bidimensional conformadas por filas (rows) y columnas (columns) las cuales, al igual que los vectores, están conformadas por datos de una misma tipología (lógicos, enteros, numéricos o doble y caracter o cadena). Representación gráfica de una matriz A continuación, se presenta la regla general para la construcción de matrices21 en R. Regla: Construcción de matrices en R En R, las matrices se construyen haciendo uso de la función matrix(). Los tipos de datos que conforman una matrix deben ser en su totalidad de la misma tipología. La función matrix() está compuesta por parámetros o argumentos entre los cuales se destacan: un conjunto de datos data que generalmente es un vectorc(), la cantidad de filas de la matriz nrow, la cantidad de columnas de la matriz ncol, un dato lógico con la forma como se conformarán los elementos dentro de la matriz byrow (por filas o columnas) y, finalmente, el argumento dimnames conformado por una lista22 en donde se define, si se considera necesario y a través de vectores de tipo caracter, los nombres de las filas y de las columnas de la matriz de datos. A Continuación, se presenta un ejemplo de creación de una matriz en R. matrix(data = c(1:9), nrow= 3, ncol = 3, byrow = TRUE, dimnames = list(c(&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;), c(&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;))) En el ejemplo anterior, el argumento data = c(1:9) nos dice que vamos a conformar una matriz con los números del 1 al 9 contenidos dentro del vector c(1:9). Los argumentos nrow = 3 y ncol = 3 nos dicen que vamos a conformar una matriz de tres filas y tres columnas (3x3). El argumento byrow = TRUE nos dice que los números del 1 al 9 serán ingresados a la matriz a través de filas -primero la fila 1, luego la 2 y por último, la fila 3-. Finalmente, el argumento dimnamescontiene una lista con dos vectores que conforman los nombres de las filas c('F1', 'F2', 'F3') así como los nombres de las columnas c('C1', 'C2', 'C3') de la matriz del presente ejemplo. Al evaluar esta matriz en R, obtendremos el siguiente resultado. ## C1 C2 C3 ## F1 1 2 3 ## F2 4 5 6 ## F3 7 8 9 Si, por ejemplo, en la matriz anterior, estamos interesados en cambiar el ingreso de los elementos que conforman la matriz de datos (de filas a columnas), basta con cambiar el argumento byrow de TRUE a FALSE. A continuación, se presenta la matriz de datos resultante al cambiar este argumento. matrix(data = c(1:9), nrow= 3, ncol = 3, byrow = FALSE, dimnames = list(c(&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;), c(&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;))) ## C1 C2 C3 ## F1 1 4 7 ## F2 2 5 8 ## F3 3 6 9 En R, a menos que se diga lo contrario, el ingreso de los datos a una matriz se da por columnas (por defecto byrow = FALSE); así mismo, este puede omitir tanto el nombre de las filas o columnas de la matriz como el número de filas, siempre y cuando, se diga el número de columnas o viceversa. A continuación, se presenta el mismo ejemplo de la matriz anterior en donde se evalúa(imprime) únicamente dos de sus argumentos. matrix(data = c(1:9), nrow= 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 En la matriz anterior, el lenguaje entiende que estamos interesados en obtener una matriz con tres filas conformada por los números del 1 al 9. Por defecto, R entiende/asume que byrow = FALSE; es decir, los datos se ingresarán por columnas y que no estamos interesados en definir los nombres de las filas y las columnas de dicha matriz. En este caso, le hemos indicado a R que conforme una matriz de tres filas y que cree tantas columnas como sea necesario para que en dicha matriz existan los elementos con los números del 1 al 9; desde luego, 3 es la cantidad de columnas requeridas23 para conformar una matriz de tres filas con los elementos del 1 al 9. A continuación, se presentan 10 ejemplos de diversas matrices creadas en R. Invitamos al lector a explorar y analizar la forma como el lenguaje evalúa/procesa cada una de estas matrices. Ejemplo. Creación de matrices en R # Ejemplo 1 - Por defecto - columnas matrix(c(1:5)) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 # Ejemplo 2 - Indicando filas y columnas matrix(1L:12L, nrow = 4, ncol = 3) ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 # Ejemplo 3 - Por filas matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 # Ejemplo 4 - Sin definir columnas matrix(1:12, nrow = 4) ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 # Ejemplo 5 - Sin definir filas matrix(1:12, ncol = 4) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Ejemplo 6 - Con secuencias y creación de variables M &lt;- matrix(seq(from = 2, to = 8, by = 2), nrow = 2, ncol = 2) M ## [,1] [,2] ## [1,] 2 6 ## [2,] 4 8 # Ejemplo 7 - Con repeticiones matrix(rep(1,4), nrow = 2, ncol = 2) ## [,1] [,2] ## [1,] 1 1 ## [2,] 1 1 # Ejemplo 8 - Con elementos lógicos matrix(c(TRUE, FALSE, FALSE, TRUE), nrow = 2, ncol = 2) ## [,1] [,2] ## [1,] TRUE FALSE ## [2,] FALSE TRUE # Ejemplo 9 - Con elementos tipo caractér - cadena matrix(c(&#39;Lunes&#39;, &#39;Martes&#39;, &#39;Miércoles&#39;, &#39;Jueves&#39;, &#39;Viernes&#39;, &#39;Sábado&#39;), nrow = 3, ncol = 2) ## [,1] [,2] ## [1,] &quot;Lunes&quot; &quot;Jueves&quot; ## [2,] &quot;Martes&quot; &quot;Viernes&quot; ## [3,] &quot;Miércoles&quot; &quot;Sábado&quot; # Ejemplo 10 - Reciclando elementos matrix(1:7, ncol = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 1 ## [3,] 3 6 2 2.6.2.1 Indexación/subconjuntos de matrices En R, al igual que en el caso de los vectores, una de las actividades de mayor uso en la gestión de matrices es la selección de elementos o subconjuntos de elementos de estas. La selección de elementos de una matriz en R se soporta en la siguiente regla. Regla. Subconjuntos de matrices en R Para extraer elementos de una matriz en R se hace uso de corchetes [ , ]. La coma, entre los corchetes, nos permite separar, haciendo uso de vectores, los elementos o subconjuntos de elementos de interés según su ubicación tanto en filas como en columnas. Si disponemos, por ejemplo, de una matriz M conformada por la matriz matrix(c(1:16), nrow = 4), cuyo resultado se presenta a continuación. ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 Y si, por ejemplo, estamos interesados en extraer el elemento de la matriz M ubicado en la fila 2 y la columna 3; es decir, el número 10, basta con implementar en R la línea de código M[2, 3]24. De igual manera, si deseamos obtener la totalidad de elementos que conforman la fila 4 de la matriz M, basta con implementar la línea de comando M[4, ]25. Finalmente, si estamos interesados en obtener los elementos -subconjunto o submatriz- ubicados entre las filas 3 y 4 y las columnas 1 y 2 de la matriz M, se deberá implementar la siguiente línea de comando en R M[c(3,4), c(1,2)]. A continuación, se presenta el desarrollo en R de los anteriores subconjuntos de elementos de la matriz M. # Construcción y visualización de la matriz M M &lt;- matrix(c(1:16), nrow = 4) M ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 # Selección del elemento ubicado en la fila 2 y la columna 3 - opción 1 M[2, 3] ## [1] 10 # Selección del elemento ubicado en la fila 2 y la columna 3 - opción 2 M[c(2), c(3)] ## [1] 10 # Selección de la totalidad de elementos ubicados en la fila 4. M[4, ] ## [1] 4 8 12 16 # Selección de la totalidad de elementos ubicados en la columna 4 M[ , 4] ## [1] 13 14 15 16 # selección de los elementos ubicados en las filas 3 y 4 y en las columnas 1 y 2 (submatriz). M[c(3,4), c(1,2)] ## [,1] [,2] ## [1,] 3 7 ## [2,] 4 8 De manera general, la selección de elementos o subconjuntos de elementos de una matriz en R, al igual que en caso de vectores, se puede realizar a través del uso de 6 tipos de opciones de las cuales se presentan, en este documento, ejemplos para 4 de ellas: vectores con enteros positivos, vectores con enteros negativos, vectores lógicos y vectores de tipo caracter26. A continuación, se presentan algunos ejemplos de extracción de elementos de una matriz en R haciendo uso de los cuatro tipos de vectores previamente anunciados. Ejemplo. Extracción de elementos de matrices en R según tipos de vectores # Creación y evaluación/visualización de una matriz en R N &lt;- matrix(data = c(1:9), nrow= 3, ncol = 3, byrow = FALSE, dimnames = list(c(&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;), c(&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;))) N ## C1 C2 C3 ## F1 1 4 7 ## F2 2 5 8 ## F3 3 6 9 # Ejemplo 1. Extracción de elementos haciendo uso de enteros positivos # selección de filas 1 y 2 y columnas 2 y 3 # Esta línea de código es equivalente a: N[c(1L, 2L), c(2L, 3L)] N[c(1, 2), c(2, 3)] ## C2 C3 ## F1 4 7 ## F2 5 8 # Ejemplo 2. Extracción de elementos haciendo uso de enteros negativos # selección de elementos ubicados en una posición diferente de la fila 1 y la columna 2 # Esta línea de código es equivalente a: N[c(-1), c(-2)] o N[-c(1), -c(2)] N[-1, -2] ## C1 C3 ## F2 2 8 ## F3 3 9 # Ejemplo 3. Extracción de elementos haciendo uso de elementos lógicos # selección de elementos ubicados en las filas 1 y 3 y las columnas 1 y 3 # Esta línea de código es equivalente a: N[c(TRUE, FALSE), c(TRUE, FALSE)], por qué? N[c(TRUE, FALSE, TRUE), c(TRUE, FALSE, TRUE)] ## C1 C3 ## F1 1 7 ## F3 3 9 # Ejemplo 4. Extracción de elementos haciendo uso de elementos de tipo caracter # selección de elementos ubicados en las filas 1 y 2 y las columnas 2 y 3 N[c(&#39;F1&#39;, &#39;F2&#39;), c(&#39;C2&#39;, &#39;C3&#39;)] ## C2 C3 ## F1 4 7 ## F2 5 8 2.6.2.2 Funciones útiles para la gestión de matrices Hasta ahora, en este documento, poco se ha hablado sobre las funciones y su importancia en este lenguaje de programación. En sentido estricto, R es un lenguaje funcional; es decir, altamente soportado en el uso de funciones. Las funciones en R, como veremos más adelante, se encuentran contenidas principalmente dentro de paquetes o librerías27. Los paquetes o librerías que contienen funciones hacen parte de dos grandes subconjuntos de librerías: las que ofrece el lenguaje por defecto al momento de su instalación y aquellas construidas por la comunidad para diversos propósitos asociados a la gestión y el análisis de datos. Por el momento, iniciaremos con el abordaje de algunas funciones de interés que hacen parte del conjunto de librerías instaladas por defecto en R; es decir, que no requieren ser invocadas/instaladas previamente para ser usadas. A medida que se avance en el desarrollo de este documento, se irá incursionando con mayor frecuencia en el acceso, entendimiento y uso de las funciones en R. Para el caso de la gestión de matrices en R, a continuación, se presentan y se describe el uso de diez28 funciones útiles para la gestión de matrices y que hacen parte de las librerías incuídas por defecto en este lenguaje29. class(): Verifica si el tipo de objeto o estructura de datos es una matriz. nrow(): Retorna el número de filas de una matriz. ncol(): Retorna el número de columnas de una matriz. dim(): Retorna las dimensiones de una matriz; es decir, cuántas filas y cuántas columnas tiene. rowSums(): Retorna un vector con la suma de los elementos que conforman las filas de una matriz. colSums(): Retorna un vector con la suma de los elementos que conforman las columnas de una matriz. rbind(): Permite adicionar filas a una matriz. cbind(): Permite adicionar columnas a una matriz. rownames(): Permite ingresar los nombres de las filas de una matriz. colnames(): Permite ingresar los nombres de las columnas de una matriz. A continuación, a través de una matriz de ejemplo, se presenta el uso de las anteriores funciones en el contexto de la gestión de matrices en R. Se invita al lector a explorar y analizar la forma como operan en R cada una de estas funciones. Ejemplo. Uso de funciones para la gestión de matrices en R # Crea una matriz en R, almacenar su resultado en una variable M y visualizar su contenido. M &lt;- matrix(data = c(1:6), ncol = 2, byrow = TRUE) M ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 # Determinar la clase de la estructura de datos M - función class() class(M) ## [1] &quot;matrix&quot; # Determinar el número de filas de la matriz M - función nrow() nrow(M) ## [1] 3 # Determinar el número de columnas de la matriz M - función ncol() ncol(M) ## [1] 2 # Determinar las dimensiones de la matriz M - función dim() dim(M) ## [1] 3 2 # Calcular un vector con las suma de las filas de la matriz M - función rowSums() rowSums(M) ## [1] 3 7 11 # Calcular un vector con las suma de las columnas de la matriz M - función colSums() colSums(M) ## [1] 9 12 # Adicionar una fila a la Matriz M - función rbind() # ¿Qué tiene de especial la función rbind() en comparación con las anteriores funciones? M &lt;- rbind(M, c(7, 8)) M ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 # Adicionar una columna a la matriz M - función cbind() # ¿Por qué se adiciona un vector con cuatro elementos y no uno con tres? M &lt;- cbind(M, c(1, 2, 3, 4)) M ## [,1] [,2] [,3] ## [1,] 1 2 1 ## [2,] 3 4 2 ## [3,] 5 6 3 ## [4,] 7 8 4 # Adicionar los nombres de las filas de la matriz M - función rownames() # Qué tiene de especial esta función en comparación con las anteriores? rownames(M) &lt;- c(&#39;Fil_1&#39;, &#39;Fil_2&#39;, &#39;Fil_3&#39;, &#39;Fil_4&#39;) M ## [,1] [,2] [,3] ## Fil_1 1 2 1 ## Fil_2 3 4 2 ## Fil_3 5 6 3 ## Fil_4 7 8 4 # Adicionar los nombres de las columnas de la matriz M - función colnames() # La variable con la que iniciamos tenía 2 columnas # ¿Por qué en esta línea de código la matriz M tiene 3 columnas? colnames(M) &lt;- c(&#39;Col_1&#39;, &#39;Col_2&#39;, &#39;Col_3&#39;) M ## Col_1 Col_2 Col_3 ## Fil_1 1 2 1 ## Fil_2 3 4 2 ## Fil_3 5 6 3 ## Fil_4 7 8 4 2.6.3 Data.frames La cuarta estructura de datos empleada por R son los data.frames o marcos de datos. Estas estructuras de datos, como se ilustra en la siguiente imagen, son estructuras de tipo bidimensional conformadas por filas (individuos) y columnas (variables). Los data.frames, a diferencia de los vectores, matrices y arreglos, no exigen un mismo tipo de dato en su conformación; estos pueden estar conformados por datos de diferente tipología entre columnas. No obstante, estas estructuras de datos exigen la misma tipología de datos al interior de cada una de sus columnas. Representación gráfica de un data.frame (marco de datos) Los marcos de datos (data.frame) es la estructura de datos más empleada para almacenar la información requerida en el análisis de datos en R al permitir almacenar/disponer la información proveniente de poblaciones o muestras conformadas por individuos para los cuales se dispone información de interés contenida en variables. Es decir, en un data.frame una fila representa/contiene la información de un individuo bajo estudio y una columna la información de una variable disponible para la totalidad de los individuos. A continuación, se presenta la regla general para la construcción de data.frames en R. Regla: Construcción de data.frame en R En R, los marcos de datos o data.frame se construyen haciendo uso de la función data.frame(). Dentro de la función data.frame(), la información de las variables está contenida en vectores con elementos de la misma tipología. 2.6.3.1 ¿Cómo crear data.frames? En R, existen principalmente dos manera de crear marcos de datos o data.frames. En primer lugar, a través de un proceso de importación de datos por parte del usuario haciendo uso de un conjunto de funciones disponibles para este propósito o ingresando los mismos a través de líneas de comando haciendo uso de la función data.frame(). Aunque el mecanismo convencional de creación/diposición de data.frames se da como resultado de procesos de importación de datos desde fuentes externas30, en esta sección nos concentraremos en la creación de data.frames por parte del usuario con el fin de comprender la filosofía de estas estructuras de datos en R. Por ejemplo, supongamos que disponemos de la información del sexo, la edad, la presencia de discapacidades (Sí o No) y la calificación obtenida en un examen por un grupo de 6 estudiantes y que deseamos que la misma sea almacenada/contenida en un marco de datos o data.frame llamado Curso en R. La edad de los estudiantes está contenida en el vector entero Edad &lt;- c(17L, 26L, 19L, 20L, 15L, 22L), el sexo en un vector caracter o textual Sexo &lt;- c('Mujer', 'Hombre', 'Hombre', 'Mujer', 'Hombre', 'Mujer'), la presencia de discapacidades en un vector lógico Discapacidad &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE) y la nota en un vector numérico Nota &lt;- c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5). Para crear de manera manual el marco de datos en R con la información de los estudiantes del ejemplo, existen dos posibilidades: ingresando la información contenida en los vectores Edad, Sexo, Discapacidad y Nota de manera directa dentro de la función data.frame() o creando/almacenando la información en variables y luego llamando/invocando estas dentro de la funcióndata.frame(). A continuación, se crean en R los marcos de datos con la información de los estudiantes del presente ejemplo. Ejemplo. Creación de marcos de datos (data.frame) en R de manera manual # Alternativa 1 - Creación de data.frame de manera directa Curso_A1 &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5) ) Curso_A1 ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Alternativa 2 - Creación de data.frame a través de variables # Definiendo las variables Edad &lt;- c(17L, 26L, 19L, 20L, 15L, 22L) Sexo &lt;- c(&quot;Mujer&quot;, &quot;Hombre&quot;, &quot;Hombre&quot;, &quot;Mujer&quot;, &quot;Hombre&quot;, &quot;Mujer&quot;) Discapacidad &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE) Nota &lt;- c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5) # Creando el data.frame Curso_A2 &lt;- data.frame(Edad, Sexo, Discapacidad, Nota) Curso_A2 ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 2.6.3.2 Indexación/subconjuntos en data.frames Al igual que el caso de vectores y de matrices, una de las actividades que más se usa a la hora gestionar marcos de datos en R con propósitos analíticos es la indexación o extracción de subconjuntos de variables o de individuos que cumplen alguna condición deseada. La actividad de extracción de subconjuntos de elementos en un data.frame, tiene tres propósitos: extraer subconjuntos de variables, extraer subconjuntos de invividios o extraer subconjuntos tanto de variables como de individuos. En R, existen tres operadores o formas ([], [[]] y $) para la selección de variables e/o individuos que hacen parte de data.frames. A continuación, se presenta la regla del lenguaje asociada a la indexación de data.frame en R. Regla. Subconjuntos de variables e/o individuos en data.frame Para extraer variables e/o individuos de un marco de datos (data.frame) en R se puede hacer uso de tres operadores [], [[]] o $. Para presentar, a través de ejemplos, los propósitos buscados con la creación de subconjuntos de variables o de elementos a partir de marcos de datos en R, en esta sección del documento haremos uso de un conjunto de datos data.frame() llamado iris el cual viene incluido por defecto31 en el software estadístico R. El conjunto de datos data.frame iris contiene la información de 150 flores y 5 variables de interés. A continuación, haciendo uso de algunas funciones útiles para la gestión de marcos de datos en R y que se presentarán con más detalle en la parte final de este apartado, se presenta una descripción rápida del contenido y las características del conjunto de datos iris. Descripción del marco de datos (data.frame) iris # Evaluar la tipología del conjunto de datos iris class(iris) ## [1] &quot;data.frame&quot; # Dimensiones del conjunto de datos iris (150 registros y 5 variables) dim(iris) ## [1] 150 5 # Nombres de las variables del conjunto de datos iris names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; # Primeros 5 registros/individuos del conjunto de datos iris head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Últimos 5 registros/individuos del conjunto de datos iris tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica 2.6.3.2.1 Subconjuntos de variables en data.frame La actividad de extracción de subconjuntos de variables en data.frame en R tiene el objetivo de seleccionar aquellas variables que hacen parte de un conjunto de datos disponible y que resultan de interés para ciertos propósitos analíticos. En R, la selección de variables de un marco de datos puede a su vez subdividerse en dos grandes propósitos: selección de una variable o selección de más de una variable. 2.6.3.2.1.1 Selección de una variable en un data.frame La selección de una variable de un conjunto de datos (data.frame) en R se puede dar a través de tres formas: haciendo uso de los operadores [], [[]] y $. A continuación, se presenta el desarrollo de cada una de estas formas de selección. Selección de un variable haciendo uso del operador [] La selección de una variable contenida en un marco de datos haciendo uso del operador [] puede realizarse a través de dos vías: definiendo, dentro del operador, la posición de la variable de interés o haciendo uso del nombre de la variable. Así mismo, la posición o el nombre de la variable de interés, puede o no estar antecedida por una coma hecho que conlleva a que el resultado conserve o no la misma estructura del conjunto de datos fuente. A continuación, se presentan algunos ejemplos haciendo uso del conjunto de datos iris, para la selección de una única variable en R haciendo uso del operador []. Ejemplo. Alternativas de selección de una variable de un data.frame haciendo uso del operador [] # Ejemplo 1 # Selección de la variable ubicada en la posición 1 - # Se conserva la estructura del conjunto de datos original (data.frame) iris[1] ## Sepal.Length ## 1 5.1 ## 2 4.9 ## 3 4.7 ## 4 4.6 ## 5 5.0 ## 6 5.4 ## 7 4.6 ## 8 5.0 ## 9 4.4 ## 10 4.9 ## 11 5.4 ## 12 4.8 ## 13 4.8 ## 14 4.3 ## 15 5.8 ## 16 5.7 ## 17 5.4 ## 18 5.1 ## 19 5.7 ## 20 5.1 ## 21 5.4 ## 22 5.1 ## 23 4.6 ## 24 5.1 ## 25 4.8 ## 26 5.0 ## 27 5.0 ## 28 5.2 ## 29 5.2 ## 30 4.7 ## 31 4.8 ## 32 5.4 ## 33 5.2 ## 34 5.5 ## 35 4.9 ## 36 5.0 ## 37 5.5 ## 38 4.9 ## 39 4.4 ## 40 5.1 ## 41 5.0 ## 42 4.5 ## 43 4.4 ## 44 5.0 ## 45 5.1 ## 46 4.8 ## 47 5.1 ## 48 4.6 ## 49 5.3 ## 50 5.0 ## 51 7.0 ## 52 6.4 ## 53 6.9 ## 54 5.5 ## 55 6.5 ## 56 5.7 ## 57 6.3 ## 58 4.9 ## 59 6.6 ## 60 5.2 ## 61 5.0 ## 62 5.9 ## 63 6.0 ## 64 6.1 ## 65 5.6 ## 66 6.7 ## 67 5.6 ## 68 5.8 ## 69 6.2 ## 70 5.6 ## 71 5.9 ## 72 6.1 ## 73 6.3 ## 74 6.1 ## 75 6.4 ## 76 6.6 ## 77 6.8 ## 78 6.7 ## 79 6.0 ## 80 5.7 ## 81 5.5 ## 82 5.5 ## 83 5.8 ## 84 6.0 ## 85 5.4 ## 86 6.0 ## 87 6.7 ## 88 6.3 ## 89 5.6 ## 90 5.5 ## 91 5.5 ## 92 6.1 ## 93 5.8 ## 94 5.0 ## 95 5.6 ## 96 5.7 ## 97 5.7 ## 98 6.2 ## 99 5.1 ## 100 5.7 ## 101 6.3 ## 102 5.8 ## 103 7.1 ## 104 6.3 ## 105 6.5 ## 106 7.6 ## 107 4.9 ## 108 7.3 ## 109 6.7 ## 110 7.2 ## 111 6.5 ## 112 6.4 ## 113 6.8 ## 114 5.7 ## 115 5.8 ## 116 6.4 ## 117 6.5 ## 118 7.7 ## 119 7.7 ## 120 6.0 ## 121 6.9 ## 122 5.6 ## 123 7.7 ## 124 6.3 ## 125 6.7 ## 126 7.2 ## 127 6.2 ## 128 6.1 ## 129 6.4 ## 130 7.2 ## 131 7.4 ## 132 7.9 ## 133 6.4 ## 134 6.3 ## 135 6.1 ## 136 7.7 ## 137 6.3 ## 138 6.4 ## 139 6.0 ## 140 6.9 ## 141 6.7 ## 142 6.9 ## 143 5.8 ## 144 6.8 ## 145 6.7 ## 146 6.7 ## 147 6.3 ## 148 6.5 ## 149 6.2 ## 150 5.9 # Ejemplo 2 # Selección de la variable ubicada en la posición 1 # No se conserva la estructura original (se cambia a vector). iris[, 1] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 # Ejemplo 3 # Selección de la variable con nombre Petal.Length y creación de una variable # Sin conservar la estructura de datos del conjunto fuente Petal_Length &lt;- iris[, &quot;Petal.Length&quot;] Petal_Length ## [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4 ## [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2 ## [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0 ## [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0 ## [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0 ## [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 ## [109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 ## [127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 ## [145] 5.7 5.2 5.0 5.2 5.4 5.1 # Revisar la clase de la estructura resultante haciendo uso de la función class() class(Petal_Length) ## [1] &quot;numeric&quot; # Ejemplo 4 # Selección de la variable con el nombre Sepal.Width y creación de una variable # Conservando la estructura de datos del conjunto fuente (data.frame) # Este resultado es equivalente a: iris[&quot;Sepal.Width&quot;] ¿por qué? # Presentar/imprimir sólo los primeros 5 elementos de la variable seleccionada Sepal_Width &lt;- iris[c(&quot;Sepal.Width&quot;)] head(Sepal_Width) ## Sepal.Width ## 1 3.5 ## 2 3.0 ## 3 3.2 ## 4 3.1 ## 5 3.6 ## 6 3.9 Selección de un variable haciendo uso del operador [[ ]] La selección de una variable contenida en un marco de datos haciendo uso del operador [[ ]] puede realizarse a través de dos vías: definiendo, dentro del operador, la posición de la variable de interés o haciendo uso del nombre de la variable. No obstante, a diferencia del operador [], este operador no permite la inclusión de comas en su interior y la salida siempre será un vector de datos; es decir, por defecto, no conserva la estructura de datos fuente (data.frame()) A continuación, se presentan algunos ejemplos de selección de una única variable de un data.frame en R haciendo uso del operador [[ ]]. Para ello, al igual que los ejemplos anteriores, se acudirá al uso del conjunto de datos iris. Ejemplo. Alternativas de selección de una variable de un data.frame haciendo uso del operador [[]] # Ejemplo 1 # Selección de la primera variable del conjunto de datos iris - por posición iris[[1]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 # Ejemplo 2 # Selección de la primera variable del conjunto de datos iris - por posición # Resultado equivalente al del ejemplo anterior. iris[[c(1)]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 # Ejemplo 3 # Selección de la primera variable del conjunto de datos iris - por nombre de la variable iris[[&#39;Sepal.Length&#39;]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 # Ejemplo 4 # Selección de la cuarta variable del conjunto de datos iris - por posición # Almacenar el resultado dentro de una variable Petal_Width &lt;- iris[[4]] # Evaluación/impresión de la variable Petal_Width ## [1] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.2 0.2 0.1 0.1 0.2 0.4 0.4 0.3 ## [19] 0.3 0.3 0.2 0.4 0.2 0.5 0.2 0.2 0.4 0.2 0.2 0.2 0.2 0.4 0.1 0.2 0.2 0.2 ## [37] 0.2 0.1 0.2 0.2 0.3 0.3 0.2 0.6 0.4 0.3 0.2 0.2 0.2 0.2 1.4 1.5 1.5 1.3 ## [55] 1.5 1.3 1.6 1.0 1.3 1.4 1.0 1.5 1.0 1.4 1.3 1.4 1.5 1.0 1.5 1.1 1.8 1.3 ## [73] 1.5 1.2 1.3 1.4 1.4 1.7 1.5 1.0 1.1 1.0 1.2 1.6 1.5 1.6 1.5 1.3 1.3 1.3 ## [91] 1.2 1.4 1.2 1.0 1.3 1.2 1.3 1.3 1.1 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8 ## [109] 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 1.8 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8 ## [127] 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3 ## [145] 2.5 2.3 1.9 2.0 2.3 1.8 # Verificar la clase de la variable Petal_Width class(Petal_Width) ## [1] &quot;numeric&quot; Selección de un variable haciendo uso del operador $ La selección de una variable contenida en un marco de datos haciendo uso del operador $ exige, como única alternativa y a diferencia de la selección haciendo uso del operador [[ ]], la existencia del nombre de la variable que será seleccionada; es decir, para hacer uso de este operador, la única alternativa disponible es el conocimiento del nombre de la variable que estamos interesados en seleccionar. Este operador $, al igual que el operador [[]], elimina la estructura de datos fuente data.frame() y la convierte en un vector. A continuación, se presentan algunos ejemplos de selección de una única variable de un data.frame en R haciendo uso del operador $. Para ello, al igual que los ejemplos anteriores, se acudirá al uso del conjunto de datos iris. Ejemplo. Alternativas de selección de una variable de un data.frame haciendo uso del operador $ # Ejemplo 1 # Selección de la variable llamada Sepal.Width iris$Sepal.Width ## [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5 ## [19] 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 ## [37] 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3 ## [55] 2.8 2.8 3.3 2.4 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8 ## [73] 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 2.3 3.0 2.5 ## [91] 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9 ## [109] 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2 ## [127] 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2 ## [145] 3.3 3.0 2.5 3.0 3.4 3.0 # Ejemplo 2 # Selección de la variable llamada Species iris$Species ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica # Ejemplo 3 # Selección de la variable Petal.Length y almacenamiento del resultado en una variable llamada Petal_Length Petal_Length &lt;- iris$Petal.Length Petal_Length ## [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4 ## [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2 ## [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0 ## [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0 ## [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0 ## [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 ## [109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 ## [127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 ## [145] 5.7 5.2 5.0 5.2 5.4 5.1 # Evaluación de la estructura de datos contenida en la variable previamente creada (Petal_Length) class(Petal_Length) ## [1] &quot;numeric&quot; 2.6.3.2.1.2 Selección de más de una variable en un data.frame La selección de más de una variable contenida en un marco de datos en R, se hace únicamente a través del uso del operador[] y dentro de este, acudiendo a vectores cuyos elementos pueden ser enteros positivos, enteros negativos, lógicos o de tipo caracter. El operador [] puede estar acompañado de una coma [ , ] y su resultado ser equivalente al uso del mismo sin la presencia de esta32. A continuación, se presentan las cuatro alternativas existentes en R para la selección de variables haciendo uso de los cuatro tipos de vectores previamente mencionados. Selección de más de una variable haciendo uso de vectores con enteros positivos La selección de más de una variable de un marco de datos data.frame() en R haciendo uso de vectores con enteros positivos permite seleccionar aquellas variables según su ubicación: la primera variable se ubica en la posición 1 del marco de datos data.frame(), la segunda variable en la posición 2 y así, sucesivamente. A continuación , haciendo uso del conjunto de datos iris, se presentan algunos ejemplos de selección de variables haciendo uso de vectores con enteros positivos. Dado que el conjunto de datos iris contiene 150 individuos y que la impresión en el documento de los resultados de los ejemplos de este y los siguiente componentes implica un alto uso de espacio, en la salida de cada uno de ellos se presentará, haciendo uso de la función head(), la información correspondiente a los primeros 6 individuos. Ejemplo. Selección de más de una variable de un data.frame haciendo uso de vectores con enteros positivos # Imprimir los primeros 6 elementos del conjunto de datos iris head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Ejemplo 1 # Selección de las primeras dos variables (posiciones 1 y 2) # Sin hacer uso de la coma head(iris[c(1,2)]) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 # Ejemplo 2 # Selección de las primeras dos variables (posiciones 1 y 2) # Haciendo uso de la coma head(iris[ , c(1,2)]) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 # Ejemplo 3 # Selección de las variables ubicadas en las posiciones 3, 4 y 5 # Haciendo uso de la coma head(iris[ , c(3:5)]) ## Petal.Length Petal.Width Species ## 1 1.4 0.2 setosa ## 2 1.4 0.2 setosa ## 3 1.3 0.2 setosa ## 4 1.5 0.2 setosa ## 5 1.4 0.2 setosa ## 6 1.7 0.4 setosa Selección de más de una variable haciendo uso de vectores con enteros negativos La selección de más de una variable de un marco de datos data.frame() en R haciendo uso de vectores con enteros negativos permite seleccionar aquellas variables que no se encuentran contenidas dentro de las posiciones definidas en el vector con enteros negativos. A continuación , haciendo uso del conjunto de datos iris, se presentan algunos ejemplos de selección de variables haciendo uso de vectores con enteros negativos. Ejemplo. Selección de más de una variable de un data.frame haciendo uso de vectores con enteros negativos # Imprimir los primeros 6 elementos del conjunto de datos iris head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Ejemplo 1 # Selección de todas las primeras variables, excepto la última. # Sin hacer uso de la coma head(iris[c(-5)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 # Ejemplo 2 # Selección de las primeras dos variables (posiciones 1 y 2) # Haciendo uso de la coma head(iris[ , c(-3,-4, -5)]) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 # Ejemplo 3 # Selección de las primeras dos variables (posiciones 1 y 2) # Haciendo uso de la coma # El mismo resultado del ejemplo 2 head(iris[ , -c(3, 4, 5)]) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 # Ejemplo 4 # Selección de las últimas dos variables (posiciones 4 y 5) # Almacenar los resultados en una variable Var_final &lt;- iris[ , -c(1:3)] head(Var_final) ## Petal.Width Species ## 1 0.2 setosa ## 2 0.2 setosa ## 3 0.2 setosa ## 4 0.2 setosa ## 5 0.2 setosa ## 6 0.4 setosa Selección de más de una variable haciendo uso de vectores con elementos lógicos La selección de más de una variable de un marco de datos data.frame() en R haciendo uso de vectores con elementos lógicos permite seleccionar aquellas variables en donde los elementos del vector lógico son iguales a TRUE y excluir aquellas en donde sus elementos son iguales a FALSE. El uso de vectores con elementos de tipo lógico para la selección de variables en R aplica la regla de reciclaje; es decir, si el vector lógico tiene una longitud inferior que la cantidad de variables existente en el marco de datos, este recicla sus elementos -partiendo del primero- hasta igualar la cantidad de variables existentes en el data.frame. A continuación , haciendo uso del conjunto de datos iris, se presentan algunos ejemplos de selección de variables haciendo uso de vectores con elementos lógicos. Ejemplo. Selección de más de una variable de un data.frame haciendo uso de vectores lógicos # Imprimir los primeros 6 elementos del conjunto de datos iris head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Ejemplo 1 # Selección de la variable ubicada en las posición 3 # Sin hacer uso de la coma head(iris[c(FALSE, FALSE, TRUE, FALSE, FALSE)]) ## Petal.Length ## 1 1.4 ## 2 1.4 ## 3 1.3 ## 4 1.5 ## 5 1.4 ## 6 1.7 # Ejemplo 2 # Selección de la primera y la última variables (posiciones 1 y 5) # Haciendo uso de la coma head(iris[ , c(TRUE, FALSE, FALSE, FALSE, TRUE)]) ## Sepal.Length Species ## 1 5.1 setosa ## 2 4.9 setosa ## 3 4.7 setosa ## 4 4.6 setosa ## 5 5.0 setosa ## 6 5.4 setosa # Ejemplo 3 # Selección de las variables ubicadas en las posiciones 1, 3, 5 # Aplicando la regla de reciclaje head(iris[ , c(TRUE, FALSE)]) ## Sepal.Length Petal.Length Species ## 1 5.1 1.4 setosa ## 2 4.9 1.4 setosa ## 3 4.7 1.3 setosa ## 4 4.6 1.5 setosa ## 5 5.0 1.4 setosa ## 6 5.4 1.7 setosa Selección de más de una variable haciendo uso de vectores con elementos de tipo caracter o textual La selección de más de una variable de un marco de datos data.frame() en R haciendo uso de vectores con elementos de tipo caracter o textual permite seleccionar aquellas variables de interés de acuerdo a sus nombres. A continuación , haciendo uso del conjunto de datos iris, se presentan algunos ejemplos de selección de variables haciendo uso de vectores con datos de tipo caracter o textuales. Ejemplo. Selección de más de una variable de un data.frame haciendo uso de vectores de tipo caracter (textuales) # Imprimir los primeros 6 elementos del conjunto de datos iris head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Ejemplo 1 # Selección de la variables llamadas Sepal.Length y Petal.Width # Sin hacer uso de la coma y con comillas dobles head(iris[c(&quot;Sepal.Length&quot;, &quot;Petal.Width&quot;)]) ## Sepal.Length Petal.Width ## 1 5.1 0.2 ## 2 4.9 0.2 ## 3 4.7 0.2 ## 4 4.6 0.2 ## 5 5.0 0.2 ## 6 5.4 0.4 # Ejemplo 2 # Selección de las variables llamadas Sepal.Length, Petal.Length y Species # Haciendo uso de comillas sencillas head(iris[ , c(&#39;Sepal.Length&#39;, &#39;Petal.Length&#39;, &#39;Species&#39;)]) ## Sepal.Length Petal.Length Species ## 1 5.1 1.4 setosa ## 2 4.9 1.4 setosa ## 3 4.7 1.3 setosa ## 4 4.6 1.5 setosa ## 5 5.0 1.4 setosa ## 6 5.4 1.7 setosa # Ejemplo 3 # Selección de la variable llamada Species # Almacenar el resultado en una variable llamada Tipo_flor # Sin conservar la estructura del conjunto de datos iris (data.frame) Tipo_flor &lt;- iris[ , c(&#39;Species&#39;)] # Imprimir los primeros 15 elementos. ¿Qué tiene de especial la función head() de este ejemplo? head(Tipo_flor, 15) ## [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## [11] setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica # Ejemplo 4 # Selección de la variable llamada Species # Almacenar el resultado en una variable llamada Tipo_flor # Conservando la estructura del conjunto de datos iris (data.frame) Tipo_flor &lt;- iris[c(&#39;Species&#39;)] head(Tipo_flor) ## Species ## 1 setosa ## 2 setosa ## 3 setosa ## 4 setosa ## 5 setosa ## 6 setosa 2.6.3.2.2 Subconjuntos de individuos en data.frame La actividad de extracción de subconjuntos de individuos en data.frame en R tiene el objetivo de seleccionar aquellos individuos que hacen parte de un marco de datos disponible y que son de interés para ciertos propósitos analíticos. En R, la selección de individuos de un marco de datos puede realizarse a través de tres alternativas, principalmente: haciendo uso de vectores, aplicando el operador %in% o haciendo uso de expresiones lógicas. A continuación, se presentan en detalle estas tres formas de seleccionar individuos contenidos en un marco de datos data.frame. Selección de individuos de un data.frame haciendo uso de vectores La selección de individuos de un data.frame haciendo uso de vectores puede implementarse a través de la aplicación de vectores cuyos elementos pueden ser enteros positivos, enteros negativos o lógicos33. En la selección de individuos de un data.frame haciendo uso de vectores con enteros positivos, cada uno de los elementos (enteros) del vector corresponde a las posiciones de los individuos dentro del data.frame que se desean seleccionar. En la selección de individuos de un data.frame haciendo uso de vectores con enteros negativos, cada uno de los elementos (enteros) del vector corresponde a la posiciones de los individuos dentro del data.frame que no deseamos seleccionar. Finalmente, en la selección de individuos de un data.frame haciendo uso de vectores con elementos lógicos, se seleccionarán aquellos individuos cuyos elementos se correspondan con los elementos tipo TRUE dentro del vector lógico. A continuación, haciendo uso del conjunto de datos iris, se presentan algunos ejemplos de selección de individuos de un marco de datos data.frame haciendo uso de vectores. Ejemplo. Selección de individuos de un data.frame haciendo uso de vectores # Ejemplo 1 # Haciendo uso de enteros positivos # Selección de los individuos (flores) ubicad@s en las posiciones 1, 50, 100 y 150 iris[c(1, 50, 100, 150), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 50 5.0 3.3 1.4 0.2 setosa ## 100 5.7 2.8 4.1 1.3 versicolor ## 150 5.9 3.0 5.1 1.8 virginica # Ejemplo 2 # Haciendo uso de enteros positivos # Selección de los individuos ubicados en las posiciones 5, 10, 15, .... iris[seq(from = 5, to = 150, by = 5), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 5 5.0 3.6 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 20 5.1 3.8 1.5 0.3 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 30 4.7 3.2 1.6 0.2 setosa ## 35 4.9 3.1 1.5 0.2 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 45 5.1 3.8 1.9 0.4 setosa ## 50 5.0 3.3 1.4 0.2 setosa ## 55 6.5 2.8 4.6 1.5 versicolor ## 60 5.2 2.7 3.9 1.4 versicolor ## 65 5.6 2.9 3.6 1.3 versicolor ## 70 5.6 2.5 3.9 1.1 versicolor ## 75 6.4 2.9 4.3 1.3 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 85 5.4 3.0 4.5 1.5 versicolor ## 90 5.5 2.5 4.0 1.3 versicolor ## 95 5.6 2.7 4.2 1.3 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor ## 105 6.5 3.0 5.8 2.2 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 115 5.8 2.8 5.1 2.4 virginica ## 120 6.0 2.2 5.0 1.5 virginica ## 125 6.7 3.3 5.7 2.1 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 135 6.1 2.6 5.6 1.4 virginica ## 140 6.9 3.1 5.4 2.1 virginica ## 145 6.7 3.3 5.7 2.5 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Ejemplo 3 # Haciendo uso de enteros negativos # Selección de los últimos 10 individuos iris[-c(1:140), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 141 6.7 3.1 5.6 2.4 virginica ## 142 6.9 3.1 5.1 2.3 virginica ## 143 5.8 2.7 5.1 1.9 virginica ## 144 6.8 3.2 5.9 2.3 virginica ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Ejemplo 4 # Haciendo uso de enteros negativos # Selección de los primeros 20 individuos # Guardar los resultados en una variable llamada First_20 First_20 &lt;- iris[-c(21:150), ] First_20 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 19 5.7 3.8 1.7 0.3 setosa ## 20 5.1 3.8 1.5 0.3 setosa # Ejemplo 5 # Haciendo uso de vectores lógicos # Selección de los individuos ubicados en las posiciones 5, 10, 15, .... # Aplicando la regla de reciclaje iris[c(FALSE, FALSE, FALSE, FALSE, TRUE), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 5 5.0 3.6 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 20 5.1 3.8 1.5 0.3 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 30 4.7 3.2 1.6 0.2 setosa ## 35 4.9 3.1 1.5 0.2 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 45 5.1 3.8 1.9 0.4 setosa ## 50 5.0 3.3 1.4 0.2 setosa ## 55 6.5 2.8 4.6 1.5 versicolor ## 60 5.2 2.7 3.9 1.4 versicolor ## 65 5.6 2.9 3.6 1.3 versicolor ## 70 5.6 2.5 3.9 1.1 versicolor ## 75 6.4 2.9 4.3 1.3 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 85 5.4 3.0 4.5 1.5 versicolor ## 90 5.5 2.5 4.0 1.3 versicolor ## 95 5.6 2.7 4.2 1.3 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor ## 105 6.5 3.0 5.8 2.2 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 115 5.8 2.8 5.1 2.4 virginica ## 120 6.0 2.2 5.0 1.5 virginica ## 125 6.7 3.3 5.7 2.1 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 135 6.1 2.6 5.6 1.4 virginica ## 140 6.9 3.1 5.4 2.1 virginica ## 145 6.7 3.3 5.7 2.5 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Ejemplo 6 # Haciendo uso de vectores lógicos # Selección de los individuos ubicados en las posiciones 20, 40, 60, ... # Aplicando la regla de reciclaje # Analizar detenidamente la forma de construcción del vector lógico iris[c(rep(FALSE, 19), c(TRUE)), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 20 5.1 3.8 1.5 0.3 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 60 5.2 2.7 3.9 1.4 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor ## 120 6.0 2.2 5.0 1.5 virginica ## 140 6.9 3.1 5.4 2.1 virginica Selección de individuos de un data.frame haciendo uso del operador %in% Uno de los principales tipos de variables usadas en el ámbito de la investigación en general y de las ciencias sociales y humanas en particular son las llamadas variables categóricas o cualitativas. Estas variables permiten identificar/clasificar a los individuos según una cualidad existente en estos; información del sexo, del estado civil, del país de residencia, del estrato social, etc., son algunos ejemplos de variables de tipo categórico. Para la selección de individuos de una población que cumplen una característica (modalidad) deseada de una variable cualitativa en particular o para la selección de individuos que no cumplen un patrón particular en variables de tipo cuantitativo, resulta de gran utilidad el uso del operador %in%. La selección de individuos de un marco de datos data.frame haciendo uso del operador %in% exige el acompañamiento del nombre de la variable (categórica o numérica) que contienen los atributos de interés así como el uso del operador $ previo al nombre de la variable y posterior al nombre del marco de datos data.frame que contiene dichas variables. Por ejemplo, si se desean seleccionar las flores del conjunto de datos iris cuya especie (variable Species) es igual a versicolor se tendrá que, en primer lugar, anunciar al leguaje en qué variable se ubica la especie de las flores antecedida del nombre del conjunto de datos bajo estudio -en nuestro caso iris- y separado por el operador $; es decir iris$Species. En segundo lugar, una vez definida la variable en donde se encuentra el o los atributo(s)/modalidad(es) de interés -en nuestro caso el tipo de flor cuya especie es versicolor-, se procede a incluir estas dentro de un vector de tipo cadena o caracter y a separarlo haciendo uso del operador %in%; es decir iris$Species %in% c('versicolor'). Finalmente, una vez definida la variable y los atributos de interés, se procede a la selección de los elementos de interés haciendo uso del operador de selección [ , ] precedido del nombre del marco de datos que contiene los elementos de interes -en nuestro caso iris-; es decir, iris[iris$Species %in% c('versicolor'), ]. A continuación, haciendo uso del conjunto de datos iris, se presenta el desarrollo del ejemplo del párrafo anterior así como otros ejemplos de selección de individuos haciendo uso del operador %in%. Ejemplo. Selección de individuos de un data.frame haciendo uso del operador %in% # Ejemplo 1 - ejercicio párrafo anterior # Selección de los individuos (flores) cuya especie (Species) es igual a versicolor iris[iris$Species %in% c(&#39;versicolor&#39;), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 54 5.5 2.3 4.0 1.3 versicolor ## 55 6.5 2.8 4.6 1.5 versicolor ## 56 5.7 2.8 4.5 1.3 versicolor ## 57 6.3 3.3 4.7 1.6 versicolor ## 58 4.9 2.4 3.3 1.0 versicolor ## 59 6.6 2.9 4.6 1.3 versicolor ## 60 5.2 2.7 3.9 1.4 versicolor ## 61 5.0 2.0 3.5 1.0 versicolor ## 62 5.9 3.0 4.2 1.5 versicolor ## 63 6.0 2.2 4.0 1.0 versicolor ## 64 6.1 2.9 4.7 1.4 versicolor ## 65 5.6 2.9 3.6 1.3 versicolor ## 66 6.7 3.1 4.4 1.4 versicolor ## 67 5.6 3.0 4.5 1.5 versicolor ## 68 5.8 2.7 4.1 1.0 versicolor ## 69 6.2 2.2 4.5 1.5 versicolor ## 70 5.6 2.5 3.9 1.1 versicolor ## 71 5.9 3.2 4.8 1.8 versicolor ## 72 6.1 2.8 4.0 1.3 versicolor ## 73 6.3 2.5 4.9 1.5 versicolor ## 74 6.1 2.8 4.7 1.2 versicolor ## 75 6.4 2.9 4.3 1.3 versicolor ## 76 6.6 3.0 4.4 1.4 versicolor ## 77 6.8 2.8 4.8 1.4 versicolor ## 78 6.7 3.0 5.0 1.7 versicolor ## 79 6.0 2.9 4.5 1.5 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 81 5.5 2.4 3.8 1.1 versicolor ## 82 5.5 2.4 3.7 1.0 versicolor ## 83 5.8 2.7 3.9 1.2 versicolor ## 84 6.0 2.7 5.1 1.6 versicolor ## 85 5.4 3.0 4.5 1.5 versicolor ## 86 6.0 3.4 4.5 1.6 versicolor ## 87 6.7 3.1 4.7 1.5 versicolor ## 88 6.3 2.3 4.4 1.3 versicolor ## 89 5.6 3.0 4.1 1.3 versicolor ## 90 5.5 2.5 4.0 1.3 versicolor ## 91 5.5 2.6 4.4 1.2 versicolor ## 92 6.1 3.0 4.6 1.4 versicolor ## 93 5.8 2.6 4.0 1.2 versicolor ## 94 5.0 2.3 3.3 1.0 versicolor ## 95 5.6 2.7 4.2 1.3 versicolor ## 96 5.7 3.0 4.2 1.2 versicolor ## 97 5.7 2.9 4.2 1.3 versicolor ## 98 6.2 2.9 4.3 1.3 versicolor ## 99 5.1 2.5 3.0 1.1 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor # Ejemplo 2 # Selección de los individuos cuyo valor en la variable Sepal.Width es igual a 2, 4.4 o 3.5 iris[iris$Sepal.Width %in% c(2, 4.4, 3.5), ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 28 5.2 3.5 1.5 0.2 setosa ## 37 5.5 3.5 1.3 0.2 setosa ## 41 5.0 3.5 1.3 0.3 setosa ## 44 5.0 3.5 1.6 0.6 setosa ## 61 5.0 2.0 3.5 1.0 versicolor # Ejemplo 3 # Selección de los individuos (flores) cuya especie (Species) es igual a setosa # Se presentan los primeros 6 individuos de la selcción haciendo uso de la función head() head(iris[iris$Species %in% c(&#39;setosa&#39;), ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Ejemplo 4 # Selección de los individuos (flores) cuya especie (Species) es igual a setosa o virginica # Guardar los resultados en una variable llamada Especie Especie &lt;- iris[iris$Species %in% c(&#39;virginica&#39;, &#39;setosa&#39;), ] # Visualizar los primeros 10 individuos (flores) haciendo uso de la función head head(Especie, n = 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa # Visualizar los últimos 6 individuos (flores) haciendo uso de la función tail tail(Especie) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Cantidad de individuos en el marco de datos llamado Especie - función nrow() nrow(Especie) ## [1] 100 Selección de individuos de un data.frame haciendo uso de expresiones lógicas Una de las formas más útiles y populares para la selección de los individuos que presentan ciertas características en un marco de datos data.frame() en R es el uso de expresiones lógicas. A través de estas, es posible selccionar aquellos individuos que cumplen una o más características de interés de acuerdo al comportamiento observado en las distintas variables. Por ejemplo, si acudimos nuevamente al marco de datos iris y si deseamos seleccionar aquellas flores cuya longitud del sépalo (Sepal.Length) es mayor o igual a 7.3, basta con hacer uso del operador relacional &gt;= e implementar en R la siguiente línea de código iris[iris$Sepal.Length &gt;= 7.3, ]. Así mismo, si además de conocer las flores cuyo longitud del sépalo es mayor o igual a 7.3, deseamos saber cuáles de ellas son de la especie versicolor, basta con implementar en R la siguiente línea de código en donde se acude al uso de una operación lógica combinada34 para obtener las flores con las condiciones deseadas (uso de operadores relacionales y lógicos) iris[iris$Sepal.Length &gt;= 7.3 &amp; iris$Species == 'versicolor', ]. A continuación, haciendo uso del conjunto de datos iris, se presenta el desarrollo de los ejemplos del párrafo anterior así como otros ejemplos de selección de individuos haciendo uso de expresiones lógicas. Ejemplo. Selección de individuos de un data.frame haciendo uso del expresiones lógicas # Ejemplo 1 # Flores cuya longitud del sépalo es mayor o igual a 7.3 iris[iris$Sepal.Length &gt;= 7.3, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 106 7.6 3.0 6.6 2.1 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica # Ejemplo 2 # Flores cuya longitud del sépalo es mayor o igual a 7.3 y pertenecen a la especie versicolor # Ninguna flor cumple la condición deseada iris[iris$Sepal.Length &gt;= 7.3 &amp; iris$Species == &#39;versicolor&#39;, ] ## [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;0 rows&gt; (or 0-length row.names) # Ejemplo 3 # Flores con ancho del pétalo menor o igual a 0.1 iris[iris$Petal.Width &lt;= 0.1, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 10 4.9 3.1 1.5 0.1 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 33 5.2 4.1 1.5 0.1 setosa ## 38 4.9 3.6 1.4 0.1 setosa # Ejemplo 4 # Flores con ancho del sépalo &gt;= 3.9 o ancho del pétalo &gt;= 2.4 iris[iris$Sepal.Width &gt;= 3.9 | iris$Petal.Width &gt;= 2.4, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 6 5.4 3.9 1.7 0.4 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 33 5.2 4.1 1.5 0.1 setosa ## 34 5.5 4.2 1.4 0.2 setosa ## 101 6.3 3.3 6.0 2.5 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 115 5.8 2.8 5.1 2.4 virginica ## 137 6.3 3.4 5.6 2.4 virginica ## 141 6.7 3.1 5.6 2.4 virginica ## 145 6.7 3.3 5.7 2.5 virginica # Ejemplo 5 # Flores de la especie setosa con un ancho de pétalo menor que 1.4 iris[iris$Species == &#39;setosa&#39; &amp; iris$Petal.Length &lt; 1.4, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 3 4.7 3.2 1.3 0.2 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 36 5.0 3.2 1.2 0.2 setosa ## 37 5.5 3.5 1.3 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 41 5.0 3.5 1.3 0.3 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 43 4.4 3.2 1.3 0.2 setosa # Ejemplo 6 # Flores de las especies setosa o virginica # Almacenar los resultados en una variable llamada Flor Flor &lt;- iris[iris$Species == &#39;setosa&#39; | iris$Species == &#39;virginica&#39;, ] # Revisar las primeras y las últimas 6 flores del data.frame Flor # Haciendo uso de las funciones head() y tail() head(Flor) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(Flor) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Número de individuos/flores que conforman el marco de datos Flor nrow(Flor) ## [1] 100 2.6.3.2.3 Subconjuntos de variables e individuos en data.frame La actividad de selección de elementos de un marco de datos data.frame() en R en general implica la selección de un subconjunto de individuos con ciertas variables de interés; es decir, selección de estos tanto por individuos como por variables. A continuación, teniendo en cuenta lo abordado en este componente del documento, se presentan algunos ejemplos de selección de elementos de un marco de datos data.frame que involucra tanto a sus individuos como sus variables. Para ello, acudiremos nuevamente al uso del conjunto de datos iris. Ejemplo. Selección de individuos y variables de un data.frame # Nombres de las variables del conjunto de datos (data.frame) iris # Hacer uso de la función names() names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; # Ejemplo 1 # Seleccionar las flores ubicadas en las posiciones 20, 70 y 120 # Retener la variable Sepal.Width iris[c(20, 70, 120), c(&quot;Sepal.Width&quot;)] ## [1] 3.8 2.5 2.2 # Ejemplo 2 # Seleccionar los últimos 5 individuos (flores) del data.frame iris # Seleccionar las variables ubicadas en las posiciones 1 y 2 iris[-c(1:145), c(1,2)] ## Sepal.Length Sepal.Width ## 146 6.7 3.0 ## 147 6.3 2.5 ## 148 6.5 3.0 ## 149 6.2 3.4 ## 150 5.9 3.0 # Ejemplo 3 # Selecionar las flores con ancho del sépalo (Sepal.Width) mayor o igual a 3.9 # Retener las variables ubicadas en posiciones diferentes a la 3, 4 y 5. iris[iris$Sepal.Width&gt;= 3.9, -c(3, 4, 5)] ## Sepal.Length Sepal.Width ## 6 5.4 3.9 ## 15 5.8 4.0 ## 16 5.7 4.4 ## 17 5.4 3.9 ## 33 5.2 4.1 ## 34 5.5 4.2 # Ejemplo 4 # Seleccionar las flores con ancho del sépalo &gt;= a 3.9 o ancho del pétalo &gt;= 2.4 # Retener las variables ubicadas en las posicones 1, 3, 5, ... # Recordar aplicación de la regla de reciclaje iris[iris$Sepal.Width &gt;= 3.9 | iris$Petal.Width &gt;= 2.4, c(TRUE, FALSE)] ## Sepal.Length Petal.Length Species ## 6 5.4 1.7 setosa ## 15 5.8 1.2 setosa ## 16 5.7 1.5 setosa ## 17 5.4 1.3 setosa ## 33 5.2 1.5 setosa ## 34 5.5 1.4 setosa ## 101 6.3 6.0 virginica ## 110 7.2 6.1 virginica ## 115 5.8 5.1 virginica ## 137 6.3 5.6 virginica ## 141 6.7 5.6 virginica ## 145 6.7 5.7 virginica # Ejemplo 5 # Seleccionar las flores de la especie setosa con una longitud del pétalo menor a 1.4 # Retener, para estas flores, las variables llamadas Sepal.Length y Species iris[iris$Species == &#39;setosa&#39; &amp; iris$Petal.Length &lt; 1.4, c(&quot;Sepal.Length&quot;, &quot;Species&quot;)] ## Sepal.Length Species ## 3 4.7 setosa ## 14 4.3 setosa ## 15 5.8 setosa ## 17 5.4 setosa ## 23 4.6 setosa ## 36 5.0 setosa ## 37 5.5 setosa ## 39 4.4 setosa ## 41 5.0 setosa ## 42 4.5 setosa ## 43 4.4 setosa # Ejemplo 6 # Selección de las flores pertenecientes a las especies setosa y versicolor # Selección de las variables ubicadas en las posiciones 4 y 5 ¿por qué? # Almacenar los resultados en una variable llamada Final Final &lt;- iris[iris$Species %in% c(&#39;setosa&#39;, &#39;versicolor&#39;), c(-1:-3)] # Visualizar las primeras 10 y las últimas 6 flores del data.frame Final head(Final, 10) ## Petal.Width Species ## 1 0.2 setosa ## 2 0.2 setosa ## 3 0.2 setosa ## 4 0.2 setosa ## 5 0.2 setosa ## 6 0.4 setosa ## 7 0.3 setosa ## 8 0.2 setosa ## 9 0.2 setosa ## 10 0.1 setosa tail(Final) ## Petal.Width Species ## 95 1.3 versicolor ## 96 1.2 versicolor ## 97 1.3 versicolor ## 98 1.3 versicolor ## 99 1.1 versicolor ## 100 1.3 versicolor # Visualizar la cantidad de flores/individuos existentes en el data.frame Final # Hacer uso de la función nrow() nrow(Final) ## [1] 100 2.6.3.3 Mofificar y eliminar variables o individuos en data.frames El proceso de gestión y análisis de datos en R haciendo uso de marcos de datos data.frame implica, en muchos casos, la necesidad de modificar y/o eliminar algunas de sus caracteristicas. A continuación, se presenta la forma como R permite en un data.frame modificar los nombres de las variables, eliminar y adicionar variables, modificar sus elementos y, finalmente, la forma como en este lenguaje se adicionan o eliminan individuos contenidos en un marco de datos. Para ello, acudiremos nuevamente al marco de datos data.frame definido al inicio de este apartado el cual contiene la información de 6 estudiantes y cuatro variables de interés(Edad, Sexo, Discapacidad y Nota). A continuación, se presenta el contenido de este conjunto de datos data.frame el cual, como se mencionó previamente, se conoce con el nombre de Curso. Contenido marco de datos (data.frame) llamado Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 2.6.3.3.1 Modificar nombres de variables en data.frame La primera característica que exploraremos al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite cambiar los nombres definidos en las variables. Para modificar el nombre de una o más variables de un data.frame en R, se debe hacer uso de la función names(), de los operadores [ ] y &lt;-, de un vector de enteros positivos con las posiciones de las variables a modificar y finalmente, un vector de tipo caracter con los nombres de las variables a modificar. Por ejemplo, si deseamos cambiar el nombre de la variable Nota por el de Nota_Final en el conjunto de datos data.frame que contiene la información de los estudiantes contenidos en el conjunto de datos Curso, debemos definir un vector c(4)con la posición 4 que es donde se ubica la variable Nota y uno de tipo caracter con el nuevo nombre de la variable c(Nota_Final). Una vez definidos los vectores de posiciones y de nuevos nombres para las variables, se procede al uso de las función names() y los operadores [ ] y &lt;- con el fin de consolidar la línea de código requerida para cambiar el nombre de la variable Nota por el de Nota_Final en el marco de datos Curso; esta línea de código es names(Curso)[c(4)] &lt;- c('Nota_Final'). A continuación, se presenta el desarrollo de este ejemplo y de otros en el contexto de la modificación de nombres de variables en data.frame haciendo uso, para ello, del conjunto de datos Curso. Ejemplo. Cambio de nombres de variables en marcos de datos (data.frame) # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Cambio del nombre de la variable Nota por el de Nota_Final names(Curso)[c(4)] &lt;- c(&#39;Nota_Final&#39;) # Visualización del data.frame Curso con el nombre de la variable Nota ajustado Curso ## Edad Sexo Discapacidad Nota_Final ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 2 # Cambiar el nombre de la variable Edad por Edad_F names(Curso)[c(1)] &lt;- c(&#39;Edad_F&#39;) # Visualización del data.frame Curso con el nombre de la variable Edad ajustado Curso ## Edad_F Sexo Discapacidad Nota_Final ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 3 # Cambiar el nombre de las variables Sexo y Discapacidad por Sexo_F y Discapacidad_F names(Curso)[c(2, 3)] &lt;- c(&#39;Sexo_F&#39;, &#39;Discapacidad_F&#39;) # Visualización del data.frame Curso con el nombre de las variables ajusatadas Curso ## Edad_F Sexo_F Discapacidad_F Nota_Final ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 2.6.3.3.2 Eliminar variables en data.frame La segunda característica que exploraremos al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite eliminar variables. Para eliminar una o más variables de un data.frame en R, existen dos posibilidades: haciendo uso de vectores o haciendo uso del tipo de dato NULL. A continuación, se presenta en detalle cada una de estas dos formas de eliminación de variables en data.frame en R. Eliminación de variables de data.frame haciendo uso de vectores El proceso de eliminación de variables en marcos de datos data.frame en R haciendo uso de vectores es equivalente al proceso de indexación o selección de subconjuntos de variables cuyo contenido se presentó en el apartado de indexacción de este documento. Eliminar una o más variables de un data.frame es equivalente a retener/selccionar aquellas variables que no hacen parte del proceso de eliminación. Por ejemplo, si deseamos eliminar la variable Nota del conjunto de datos Curso, basta con implementar en R una instrucción que nos permita retener el conjunto de variables diferentes a la variable Nota y para ello, desde luego, podemos acudir a un proceso de indexación de variables en R haciendo uso de vectores los cuales pueden estar conformados por enteros positivos, enteros negativos, elementos lógicos o elementos de tipo caracter. A continuación, haciendo uso del conjunto de datos Curso, se presentan algunos ejemplos de eliminación de variables de un data.frame en R haciendo uso de vectores Ejemplo. Eliminación de variables en marcos de datos (data.frame) haciendo uso de vectores # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Eliminación de la variable Nota # Indexación - haciendo uso de enteros negativos # Almacenar los resultados en un data.frame llamado Curso_1 Curso_1 &lt;- Curso[ , -c(4)] Curso_1 ## Edad Sexo Discapacidad ## 1 17 Mujer TRUE ## 2 26 Hombre FALSE ## 3 19 Hombre FALSE ## 4 20 Mujer TRUE ## 5 15 Hombre FALSE ## 6 22 Mujer FALSE # Ejemplo 2 # Eliminación de la variable Nota # Indexación - haciendo uso de enteros positivos # Almacenar los resultados en un data.frame llamado Curso_2 Curso_2 &lt;- Curso[ , c(1:3)] Curso_2 ## Edad Sexo Discapacidad ## 1 17 Mujer TRUE ## 2 26 Hombre FALSE ## 3 19 Hombre FALSE ## 4 20 Mujer TRUE ## 5 15 Hombre FALSE ## 6 22 Mujer FALSE # Ejemplo 3 # Eliminación de la variable Nota # Indexación - haciendo uso de vectores lógicos # Almacenar los resultados en un data.frame llamado Curso_3 Curso_3 &lt;- Curso[ , c(TRUE, TRUE, TRUE, FALSE)] Curso_3 ## Edad Sexo Discapacidad ## 1 17 Mujer TRUE ## 2 26 Hombre FALSE ## 3 19 Hombre FALSE ## 4 20 Mujer TRUE ## 5 15 Hombre FALSE ## 6 22 Mujer FALSE # Ejemplo 4 # Eliminación de las variable Edad y Discapacidad # Indexación - haciendo uso de vectores con elementos textuales # Almacenar los resultados en un data.frame llamado Curso_4 Curso_4 &lt;- Curso[ , c(&#39;Sexo&#39;,&#39;Nota&#39;)] Curso_4 ## Sexo Nota ## 1 Mujer 4.3 ## 2 Hombre 1.5 ## 3 Hombre 3.0 ## 4 Mujer 3.7 ## 5 Hombre 4.0 ## 6 Mujer 3.5 Eliminación de variables de data.frame haciendo uso de NULL El proceso de eliminación de variables en marcos de datos data.frame en R haciendo uso del tipo de dato NULL implica la selección e inclusión dentro de un vector35 de las variables a eliminar por nombres o posición y luego, haciendo uso de los operadores [] y &lt;-, asignar el dato NULL. por Ejemplo, el proceso de eliminar la variable Sexo del conjunto de datos Curso, implica implementar en R la siguiente línea de código Curso[ , c(2)] &lt;- NULL. A continuación, se presenta el desarrollo de este ejemplo y de otros haciendo uso del conjunto de datos Curso y del dato NULL para la eliminación de variables contenidas en data.frame. Ejemplo. Eliminación de variables en marcos de datos (data.frame) haciendo uso del tipo de dato NULL # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Eliminación de la variable Sexo # Haciendo uso de enteros positivos Curso[ , c(2)] &lt;- NULL # Visualización del marco de datos Curso sin la variable Sexo Curso ## Edad Discapacidad Nota ## 1 17 TRUE 4.3 ## 2 26 FALSE 1.5 ## 3 19 FALSE 3.0 ## 4 20 TRUE 3.7 ## 5 15 FALSE 4.0 ## 6 22 FALSE 3.5 # Ejemplo 2 # Eliminar, del data.frame resultante del ejemplo 1, las variables Edad y Nota # Haciendo uso de vectores de tipo caracter o textual Curso[ , c(&#39;Edad&#39;, &#39;Nota&#39;)] &lt;- NULL # Visualización del marco de datos Curso sin las variables Sexo, Edad y Nota Curso ## Discapacidad ## 1 TRUE ## 2 FALSE ## 3 FALSE ## 4 TRUE ## 5 FALSE ## 6 FALSE 2.6.3.3.3 Modificar elementos en data.frame La tercera característica que será explorada al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite modificar algunos de sus elementos; es decir, la información de uno o más individuos para ciertas variables. Para ello, el lenguaje exige la identificación y asignación dentro de un vector de las posiciones de los elementos a modificar en el data.frame y en un vector o lista independiente, mediado por el operador &lt;-, el o los valores a modificar para cada una de las variables de interés. Por ejemplo, modificar la nota de 3.5 a 5.0 del estudiante ubicado en la posición 1 del marco de datos Curso (primera fila), implica en R implementar la línea de código Curso[c(1), c('Nota')] &lt;- c(5.0). En este ejemplo, se le está ordenando al programa que seleccione, del conjunto de datos Curso, el dato/nota del estudiante ubicado en la primera posición c(1) y que cambie su nota c(Nota) por el valor 5 c(5.0). A continuación, haciendo uso del conjunto de datos Curso, se presenta el desarrollo de este ejemplo y de otros36 sobre modificación de elementos en R contenidos en data.frame. Ejemplo. Modificación de elementos en marcos de datos (data.frame). # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Cambiar la nota del estudiante ubicado en la posición 1 (de 3.5 a 5.0) Curso[c(1), c(&#39;Nota&#39;)] &lt;- c(5.0) # Mostrar el data.frame con el cambio requerido Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 5.0 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 2 # Cambiar a 5.0 las notas de los estudiante ubicados en la posiciones 1, 4 y 6. # Resultado equivalente a Curso[c(1, 4, 6), c(&#39;Nota&#39;)] &lt;- c(5.0, 5.0, 5.0) Curso[c(1, 4, 6), c(&#39;Nota&#39;)] &lt;- c(5.0) Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 5.0 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 5.0 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 5.0 # Ejemplo 3 # Cambiar a 5.0 las notas de los estudiante ubicados en la posiciones 1, 4 y 6. # Cambiar el Sexo a hombres de los estudiante ubicados en la posiciones 1, 4 y 6. # Hacer uso de una lista (list) para contener los vectores con los nuevos valores. Curso[c(1, 4, 6), c(&#39;Sexo&#39;, &#39;Nota&#39;)] &lt;- list(c(&#39;Hombre&#39;, &#39;Hombre&#39;, &quot;Hombre&quot;), c(5.0, 5.0, 5.0)) Curso ## Edad Sexo Discapacidad Nota ## 1 17 Hombre TRUE 5.0 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Hombre TRUE 5.0 ## 5 15 Hombre FALSE 4.0 ## 6 22 Hombre FALSE 5.0 2.6.3.3.4 Eliminar individuos en data.frame La cuarta característica que será explorada al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite eliminar individuos (filas); es decir, la información de uno o más individuos según ciertos criterios de interés. Para ello, el lenguaje ofrece dos alternativas: haciendo uso de vectores o a través de expresiones lógicas. Eliminación de individuos en data.frame haciendo uso de vectores La eliminación de individuos de un marco de datos haciendo uso de vectores es equivalente (igual) al proceso de indexación o extracción de subconjuntos de individuos presentado previamente en la sección de Indexación de data.frame. Eliminar individuos de un marco de datos data.frame haciendo uso de vectores37 es equivalente a seleccionar aquellos individuos que no pertenecen a dicho subconjunto -los que no se desean eliminar- o que son iguales a dicho subconjunto de individuos -los que se desean eliminar-. A continuación, haciendo uso del conjunto de datos Curso, se presentan algunos ejemplos de eliminación de individuos en un data.frame haciendo uso de vectores. Ejemplo. Eliminación de individuos de un marco de datos (data.frame) haciendo uso de vectores. # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Eliminar el primero y el último individuo del data.frame Curso # Guardar los resultado en una variable llamada Curso_1 # Hacer uso de un vector con enteros positivos - los que no se desean eliminar- Curso_1 &lt;- Curso[c(2:5), ] Curso_1 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 # Ejemplo 2 # Eliminar el primero y el último individuo del data.frame Curso # Guardar los resultado en una variable llamada Curso_2 # Hacer uso de un vector con enteros negativos - los que se desean eliminar- Curso_2 &lt;- Curso[-c(1, 6), ] Curso_2 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 # Ejemplo 3 # Eliminar los individuos 1, 3 y 5 del data.frame Curso # Guardar los resultado en una variable llamada Curso_3 # Hacer uso de un vector con elementos lógicos Curso_3 &lt;- Curso[c(FALSE, TRUE, FALSE, TRUE, FALSE, TRUE), ] Curso_3 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 4 20 Mujer TRUE 3.7 ## 6 22 Mujer FALSE 3.5 # Ejemplo 4 # Eliminar los individuos 2, 4 y 6 del data.frame Curso # Guardar los resultado en una variable llamada Curso_4 # Hacer uso de un vector con elementos lógicos # Aplicando la regla de reciclaje de elementos Curso_4 &lt;- Curso[c(TRUE, FALSE), ] Curso_4 ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 3 19 Hombre FALSE 3.0 ## 5 15 Hombre FALSE 4.0 Eliminación de individuos en data.frame haciendo uso de expresiones lógicas La eliminación de individuos de un marco de datos haciendo uso de expresiones lógicas es equivalente (igual) al uso de estas estructuras para la indexación o extracción de subconjuntos de individuos presentado en la sección de Indexación de data.frame. Por ejemplo, si deseamos eliminar los estudiantes del marco de datos Curso que obtuvieron una nota igual o superior a 4, debemos implementar en R la siguiente línea de comando haciendo uso de expresioens lógicas Curso[Curso$Nota &lt; 4, ] la cual es equivalente a extraer, a través de un proceso de indexación, el subconjunto de estudiantes con una nota inferior a 4. A continuación, haciendo uso del marco de datos Curso, se presenta el desarrollo de este y de otros ejemplos orientados a la eliminación de individuos de un data.frame haciendo uso de expresiones lógicas. Ejemplo. Eliminación de individuos de un marco de datos (data.frame) haciendo uso de expresiones lógicas. # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Eliminar los estudiantes con una nota igual o superior a 4 # Guardar los resultado en una variable llamada Curso_1 # Haciendo uso del operador relacional &lt; (opción 1) Curso_1 &lt;- Curso[Curso$Nota &lt; 4, ] Curso_1 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 6 22 Mujer FALSE 3.5 # Ejemplo 2 # Eliminar los estudiantes con una nota igual o superior a 4 # Guardar los resultado en una variable llamada Curso_2 # Haciendo uso del operador relacional &gt;= y del signo ! (opción 2) # Analizar y recordar el papel del operador lógico ! Curso_2 &lt;- Curso[!(Curso$Nota &gt;= 4), ] Curso_2 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 6 22 Mujer FALSE 3.5 # Ejemplo 3 # Eliminar los hombres del data.frame Curso # Guardar los resultado en una variable llamada Curso_3 # ¿Por qué se usa la opción Mujer despues del operador relacional ==? # ¿Qué ajuste debemos hacer al código si deseamos utilizar la opción Hombre después del operador relacional ==? Curso_3 &lt;- Curso[Curso$Sexo == &#39;Mujer&#39;, ] Curso_3 ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 4 20 Mujer TRUE 3.7 ## 6 22 Mujer FALSE 3.5 # Ejemplo 4 # Eliminar las mujeres con una nota igual o superior a 4 # Guardar los resultado en una variable llamada Curso_4 # Analizar y entender el contenido de esta instrucción Curso_4 &lt;- Curso[!(Curso$Sexo == &#39;Mujer&#39; &amp; Curso$Nota &gt;= 4), ] Curso_4 ## Edad Sexo Discapacidad Nota ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 2.6.3.4 Adicionar variables e individuos en data.frames Además de modificar nombres de variables, eliminar variables, modificar elementos y eliminar individuos contenidos en un marco de datos data.frame, R ofrece la posibilidad de adicionar variables o individuos a estos. A continuación, se presenta la forma como este lenguaje permite adicionar variables o individuos en un marco de datos o data.frame. 2.6.3.4.1 Adicionar variables a un data.frame La quinta característica que será explorada al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite adicionar nuevas variables (columnas) a estas estructuras de datos. Para ello, el lenguaje ofrece varias alternativas las cuales pueden ser reducidas a dos ámbitos: adición de una variable o adición de más de una variable en un marco de datos data.frame. A continuación, se presenta la forma como R adiciona variables en cada uno de estos ámbitos. Adición de una variable en un data.frame La adición de una variable en un marco de datos data.frame puede realizarse a través de dos alternativas las cuales se corresponden con los operadores $ y [[ ]] del lenguaje presentados en la sección de indexación de subconjuntos de variables en R. Por ejemplo, si deseamos adicionar una nueva variable llamada Nueva1 al conjunto de datos Curso que hemos trabajado a lo largo de este documento, podemos usar dos alternativas de código Curso$Nueva1 &lt;- c(1:6) o Curso[['Nueva1']] &lt;- c(6:1). En la primera de las líneas de código, la que hace uso del operador $, le estamos indicando al lenguaje que cree una nueva variable dentro del marco de datos Curso y que le asigne el nombre de Nueva1; es decir, Curso$Nueva1. Luego, haciendo uso del operador de asignación &lt;-, le estamos indicando al lenguaje que la variable Nueva1 contenga la información del vector c(6:1). El mismo, raciocinio puede emplearse en el caso de la línea de código que contiene el operador [[ ]]. A continuación, haciendo uso del marco de datos Curso, se presenta el desarrollo de los anteriores dos ejemplos orientados a la creación de una nueva variable dentro de un data.frame en R. Ejemplo. Alternativas de creación de una nueva variable en un marco de datos (data.frame). # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Creación de la variable Nueva1 haciendo uso del operador $ Curso$Nueva1 &lt;- c(1:6) Curso ## Edad Sexo Discapacidad Nota Nueva1 ## 1 17 Mujer TRUE 4.3 1 ## 2 26 Hombre FALSE 1.5 2 ## 3 19 Hombre FALSE 3.0 3 ## 4 20 Mujer TRUE 3.7 4 ## 5 15 Hombre FALSE 4.0 5 ## 6 22 Mujer FALSE 3.5 6 #Ejemplo 2 # Adicionar, al data.frame resultante del ejemplo 1, una nueva variable llamada Nueva2 # Haciendo uso del operador [[]] Curso[[&#39;Nueva2&#39;]] &lt;- c(6:1) Curso ## Edad Sexo Discapacidad Nota Nueva1 Nueva2 ## 1 17 Mujer TRUE 4.3 1 6 ## 2 26 Hombre FALSE 1.5 2 5 ## 3 19 Hombre FALSE 3.0 3 4 ## 4 20 Mujer TRUE 3.7 4 3 ## 5 15 Hombre FALSE 4.0 5 2 ## 6 22 Mujer FALSE 3.5 6 1 Adición de más de una variable en un data.frame La adición de más de una variable en un marco de datos data.frame puede realizarse, al igual que en el caso de una variable, a través de dos alternativas las cuales se corresponden con las funciones cbind() y list(). A continuación, haciendo uso del marco de datos Curso, se presentan algunos ejemplos de creación de más de una variable en un data.frame haciendo uso de la función cbind() y de la función list() la cual sirve de base para la creación de una estructura de datos llamada listas y que hará parte de la siguiente sección del presente documento. Ejemplo. Alternativas de creación de más de una variable en un marco de datos (data.frame). # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Haciendo uso de la función cbind() # Crear dos variables. # Nueva1 con el contenido del vector rep(5, 6) # Nueva2 con la información del vector rep(1, 6) # Almacenar los resultados del nuevo data.frame en un variable llamada Curso_Ajustado Curso_Ajustado &lt;- cbind(Curso, data.frame(Nueva1 = rep(5, 6), Nueva2 = rep(1, 6))) Curso_Ajustado ## Edad Sexo Discapacidad Nota Nueva1 Nueva2 ## 1 17 Mujer TRUE 4.3 5 1 ## 2 26 Hombre FALSE 1.5 5 1 ## 3 19 Hombre FALSE 3.0 5 1 ## 4 20 Mujer TRUE 3.7 5 1 ## 5 15 Hombre FALSE 4.0 5 1 ## 6 22 Mujer FALSE 3.5 5 1 # Ejemplo 2 # Haciendo uso de la función list() # Crear la variable llamada Nueva3 con 6 números aleatorios de una distrinución normal N(0, 1) # Requiere definir un vector con la posisión en donde se almacenará la nueva variable c(5) # recordar que el conjunto de datos Curso está conformado por cuatro variables Curso[, c(5)] &lt;- list(Nueva3 = rnorm(6)) Curso ## Edad Sexo Discapacidad Nota Nueva3 ## 1 17 Mujer TRUE 4.3 0.3142315 ## 2 26 Hombre FALSE 1.5 -0.7208735 ## 3 19 Hombre FALSE 3.0 -1.0607445 ## 4 20 Mujer TRUE 3.7 0.6541960 ## 5 15 Hombre FALSE 4.0 0.0979505 ## 6 22 Mujer FALSE 3.5 -1.4353098 # Ejemplo 3 # Haciendo uso de la función list() # Adicionar, al marco de datos del ejemplo 2, dos nuevas variables (Nueva4 y Nueva5) # Almacenar la información de la variable Nueva4 en una variable previa llamada Normal # Analizar la forma como R procesa este ejemplo Normal &lt;- rnorm(6) Curso[, c(6, 7)] &lt;- list(Nueva4 = Normal, Nueva5 = rep(1, 6)) Curso ## Edad Sexo Discapacidad Nota Nueva3 Nueva4 Nueva5 ## 1 17 Mujer TRUE 4.3 0.3142315 -0.4986171 1 ## 2 26 Hombre FALSE 1.5 -0.7208735 0.1202771 1 ## 3 19 Hombre FALSE 3.0 -1.0607445 0.6425142 1 ## 4 20 Mujer TRUE 3.7 0.6541960 1.0608351 1 ## 5 15 Hombre FALSE 4.0 0.0979505 0.1018791 1 ## 6 22 Mujer FALSE 3.5 -1.4353098 0.6331869 1 2.6.3.4.2 Adicionar individuos a un data.frame La sexta y última característica que será explorada en este documento al momento de interactuar con marcos de datos data.frame en R es la forma como este lenguaje permite adicionar nuevos individuos. Para ello, el lenguaje requiere la definición de las posiciones que ocuparán los nuevos individuos y el uso de la función list() la cual, como se mencionó previamente, nos servirá de base para el desarrollo de la siguiente sección de trabajo en donde se abordarán las estructuras de datos conocidas como listas. Por ejemplo, si deseamos adicionar un nuevo estudiante (posición/fila 7) al conjunto de datos Curso que tiene 26 años de edad, que es hombre, que no presenta discapacidades y que obtuvo una nota de 2.0, debemos imprementar en R la siguiente instrucción Curso[c(7), ] &lt;- list(Edad = c(26), Sexo = c('Hombre'), Discapacidad = c(FALSE), Nota = c(2.0)). A continuación, haciendo uso del marco de datos Curso, se presenta el desarrollo de este ejemplo y de otros asociados a la adición de individuos en un data.frame. Ejemplo. Adición de individuos en un marco de datos (data.frame). # Creación del conjunto de datos (data.frame) Curso Curso &lt;- data.frame(Edad = c(17L, 26L, 19L, 20L, 15L, 22L), Sexo = c(&#39;Mujer&#39;, &#39;Hombre&#39;, &#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Hombre&#39;,&#39;Mujer&#39;), Discapacidad = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE), Nota = c(4.3, 1.5, 3.0, 3.7, 4.0, 3.5)) # Visualización del marco de datos Curso Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 # Ejemplo 1 # Adicionar un nuevo estudiante con la siguiente información # Edad = 26, Sexo = Hombre, sin discapacidades y con una nota de 2.0 Curso[c(7), ] &lt;- list(Edad = c(26), Sexo = c(&#39;Hombre&#39;), Discapacidad = c(FALSE), Nota = c(2.0)) # Visualizar el data.frame con el nuevo individuo Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 ## 7 26 Hombre FALSE 2.0 # Ejemplo 2 # Adicionar dos nuevos estudiante al data.frame resultante del ejemplo 1 # ¿Por qué usamos las posiciones 8 y 9? Curso[c(8, 9), ] &lt;- list(Edad = c(20, 13), Sexo = c(&#39;Hombre&#39;, &#39;Mujer&#39;), Discapacidad = c(FALSE, TRUE), Nota = c(2.0, 3.9)) # Visualizar el data.frame resultante con los nuevos individuos Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 ## 7 26 Hombre FALSE 2.0 ## 8 20 Hombre FALSE 2.0 ## 9 13 Mujer TRUE 3.9 # Ejemplo 3 # Adicionar tres nuevos estudiantes al data.frame Curso # Almacenar el data.frame resultante en una variable llamada Curso_AF # Ingresar la información de los nuevos individuos en variables # ¿Por qué usamos, en este ejemplo, las posiciones 7, 8 y 9? # Reflexionar sobre la forma como R compila este ejemplo Edad_3 &lt;- c(23, 19, 29) Sexo_3 &lt;- c(&#39;Hombre&#39;, &#39;Mujer&#39;, &#39;Mujer&#39;) Discapacidad_3 &lt;- c(FALSE, TRUE, FALSE) Nota_3 &lt;- c(3.3, 4.9, 4.5) Curso_AF &lt;- Curso[c(7:9), ] &lt;- list(Edad = Edad_3, Sexo = Sexo_3, Discapacidad = Discapacidad_3, Nota = Nota_3) # Visualizar el data.frame resultante con los nuevos individuos Curso ## Edad Sexo Discapacidad Nota ## 1 17 Mujer TRUE 4.3 ## 2 26 Hombre FALSE 1.5 ## 3 19 Hombre FALSE 3.0 ## 4 20 Mujer TRUE 3.7 ## 5 15 Hombre FALSE 4.0 ## 6 22 Mujer FALSE 3.5 ## 7 23 Hombre FALSE 3.3 ## 8 19 Mujer TRUE 4.9 ## 9 29 Mujer FALSE 4.5 2.6.3.5 Funciones útiles para la gestión de data.frame En la sección sobre matrices de este documento se abordó un listado de funciones útiles para la gestión de dichas estructuras de datos. En R, de igual manera, existe un número importante de funciones contenidas por defecto en el software38 que resultan de gran utilidad para explorar y gestionar marcos de datos data.frame. A continuación, se presentan y describen 10 funciones aplicables a la gestión de marcos de datos en R. class(): Verifica si el tipo de objeto o estructura de datos es un data.frame. names(): Retorna un vector de tipo caracter o textual con los nombres de las variables de un data.frame. dim(): Retorna las dimensiones de un data.frame; es decir, cuántos individuos y cuántas variables tiene. length(): Retorna la cantidad (número) de variables de un data.frame. ncol(): Retorna el número de variables de un data.frame. Arroja los mismo resultados que la función length(). nrow(): Retorna el número de individuos de un data.frame. head(): Retorna, por defecto, los primeros 6 individuos de un data.frame. El número de individuos a visualizar puede ser ajustado acudiendo a uno de los argumentos de esta función. tail(): Retorna, por defecto, los últimos 6 individuos de un data.frame. El número de individuos a visualizar puede ser ajustado acudiendo a uno de los argumentos de esta función. str(): Retorna un resumen descriptivo del contenido de un data.frame: total de variables e individuos, nombres de las variables, tipología de las variables y primeros elementos de cada una de las variables. summary(): Retorna un resumen descriptivo de tipo estadístico de un data.frame. Para las variables de tipo continuo o numérico, retorna el valor mínimo, el primer cuartil, la mediana, la media, el tercer cuartil y el valor máximo; para las variables de tipo nominal o categórico, retorna las cantidad de individuos (frecuencias absolutas) por modalidad de respuesta. A continuación, haciendo uso del marco de datos iris, se presenta la aplicación de las anteriores funciones en el contexto de la gestión de marcos de datos o data.frame en R. Se invita al lector a explorar y analizar la forma como operan en R cada una de estas funciones. # Verificar el tipo de estructura de datos del conjunto de datos iris # Función class() class(iris) ## [1] &quot;data.frame&quot; # Retornar el nombre de las variables contenidas en el conjunto de datos iris # Función names() names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; # Retornar el total de individuos y de variables contenidas en el conjunto de datos iris # Función dim() dim(iris) ## [1] 150 5 # Retornar la cantidad de variables que conforman el conjunto de datos iris - opción 1 # Función length() length(iris) ## [1] 5 # Retornar la cantidad de variables que conforman el conjunto de datos iris - opción 2 # Función ncol() ncol(iris) ## [1] 5 # Retornar la cantidad de individuos (flores) que conforman el conjunto de datos iris # Función nrow() nrow(iris) ## [1] 150 # Imprimir la información de los primeros 6 individuos (flores) del conjunto de datos iris # Función head() head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Imprimir la información de los últimos 6 individuos (flores) del conjunto de datos iris # Función tail() tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica # Presentar un resumen general de las características del conjunto de datos iris # Función str() str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # Retornar un resumen descriptivo estadístico de las variables del conjunto de datos iris # Función summary summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## 2.6.4 Listas La quinta estructura de datos empleada por R son las listas. Estas estructura de datos, como se ilustra en la siguiente imagen, son estructura de tipo multidimensional que permite en su interior la disposición de otras estructuras de datos. Representación gráfica de una lista Las listas, a diferencia de los vectores, las matrices, los arreglos y los marcos de datos data.frame, no exigen ningún requisito para su conformación. En ellas pueden ser almacenadas objetos de diversas tipologías como, por ejemplo, los hasta hora vistos. Es decir, una lista puede estar compuesta por vectores, matrices, data.frame e incluso, otras listas. A continuación, se presenta la regla general para la construcción de listas en R. Regla: Construcción de listas en R En R, las listas se construyen haciendo uso de la función list(). Dentro de la función list(), se definen los objetos que esta contendrá los cuales pueden ser de cualquier naturaleza, incluso otras listas. Aunque las listas no se usan de manera frecuente en los análisis de datos convencionales39, estas resultan de amplia utilidad para la conformación del lenguaje y para la construcción de paquetes o librerías en R a los cuales acudimos de manera regular para ciertos propósitos. A continuación, se presenta un ejemplo de creación de una lista en R y que hemos decidio guardar/almacenar dentro de un objeto llamado Mi_primera_lista. Ejemplo. Creación de listas en R # Creación de objetos/variables que contendrá la lista vector_1 &lt;- c(1, 2, 3, 4) matriz_1 &lt;- matrix(c(1:4), nrow=2, byrow = TRUE) marco_1 &lt;- head(iris) vector_2 &lt;- c(TRUE, FALSE, TRUE) marco_2 &lt;- tail(mtcars) lista_1 &lt;- list(Letras = LETTERS[c(1:5)], Matriz = matrix(c(1:9), nrow=3)) # Creación de la lista a partir de los objetos previamente creados Mi_primera_lista &lt;- list(Elemento1 = vector_1, Elemento2 = matriz_1, Elemento3 = marco_1, Elemento4 = vector_2, Elememnto5 = marco_2, Elemento6 = lista_1) # Impresión/presentación de los resultados de la lista Mi_primera_lista ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento3 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $Elemento4 ## [1] TRUE FALSE TRUE ## ## $Elememnto5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 ## ## $Elemento6 ## $Elemento6$Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Elemento6$Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 En el ejemplo anterior hemos creado, haciendo uso de la función list(), una lista llamada Mi_primera_lista la cual está conformada por 6 elementos40. El primer elemento de esta lista, identificado como Elemento141 en el resultado anterior, está conformato por por el vector c(1, 2, 3, 4). El segundo elemento, nombrado como Elemento2, está conformado por una matriz de 2 filas y dos columnas con datos que se han ingresado por filas (byrow = TRUE). El tercer elemento, identificado como Elemento3, está conformado por un data.frame con los primeros 6 individuos del marco de datos iris. El cuarto elemento, nombrado como Elemento4, está compuesto por el vector lógico c(TRUE, FALSE, TRUE). El quinto elemento, identificado como Elemento5, está conformado por un data.frame con los últimos 6 individuos del marco de datos mtcars. Finalmente, el sexto elemento del la lista Mi_primera_lista está conformado a su vez por otra lista identificada en la consola o salida de R como Elemento6 la cua está compuesta por dos elementos: un vector de tipo caracter o textual con las primeras 5 letras mayúsculas del alfabeto romano LETTERS[c(1:5)] e identificado como Letras y una matriz de 3 filas y 3 columnas matrix(c(1:9), nrow=3) identificada como Matriz. 2.6.4.1 Indexación/subconjuntos en listas Al igual que el caso de vectores, matrices y marcos de datos o data.frame, una de las actividades que más se usa a la hora gestionar listas en R es la indexación o extracción de subconjuntos de elementos. En R, al igual que en el caso de data.frame, existen tres operadores o formas ([], [[ ]] y $) para la selección de los elementos de una lista. A continuación, se presenta la regla del lenguaje asociada a la indexación de listas en R. Regla. Subconjuntos de elementos en listas El proceso de extracción de elementos de una lista en R implica el uso de tres operadores: [], [[]] o $. El operador $ exige que los elementos de las listas tengan asignado un nombre. En las listas, al igual que en los marcos de datos o data.frame, el uso de los anteriores operadores para la selección de elementos dependerá si se desea seleccionar uno o más de sus elementos. Mientras que los operadores [], [[ ]] y $ pueden ser usados para la selección de un único elemento de una lista, para el caso de la selección de más de un elemento, únicamente puede ser usado el operador []. 2.6.4.1.1 Selección de un elemento de una lista Como se acaba de presentar, la selección de un elemento contenido en una lista de R se puede dar a través de tres formas: haciendo uso de los operadores [], [[ ]] y $. A continuación, se presenta el desarrollo de cada una de estas formas de selección. Selección de un elemento de una lista haciendo uso del operador []. La selección de un elemento de una lista haciendo uso del operador [] exige la inclusión, dentro de los corchetes, del nombre o la posición del elemento que será seleccionado. El objeto resultante de este mecanismo de selección conserva la estructura del objeto original; es decir, continúa siendo una lista. Selección de un elemento de una lista haciendo uso del operador [[ ]]. La selección de un elemento de una lista haciendo uso del operador [[ ]] exige la inclusión, dentro de los dobles corchetes, del nombre o la posición del elemento que será seleccionado. El objeto resultante de este mecanismo, a diferencia del caso anterior, no conserva la estructura del objeto original; es decir, no continúa siendo una lista a menos que el elemento seleccionado sea a su vez una lista. Selección de un elemento de una lista haciendo uso del operador $. La selección de un elemento de una lista haciendo uso del operador $ exige el nombre o la posición del elemento que será seleccionado. El objeto resultante de este mecanismo, al que en el caso del operador [[ ]], no conserva la estructura del objeto original; es decir, no continúa siendo una lista a menos que el elemento seleccionado sea a su vez una lista. A continuación, haciendo uso de la lista creada previamente y llamada Mi_primera_lista, se presentan algunos ejemplos de selección de un único elemento a partir de una lista disponible en R. Ejemplo. Selección de un elemento de una lista de R # Creación de variables/elementos para la lista vector_1 &lt;- c(1, 2, 3, 4) matriz_1 &lt;- matrix(c(1:4), nrow=2, byrow = TRUE) marco_1 &lt;- head(iris) vector_2 &lt;- c(TRUE, FALSE, TRUE) marco_2 &lt;- tail(mtcars) lista_1 &lt;- list(Letras = LETTERS[c(1:5)], Matriz = matrix(c(1:9), nrow=3)) # Creación de la lista Mi_primera_lista &lt;- list(Elemento1 = vector_1, Elemento2 = matriz_1, Elemento3 = marco_1, Elemento4 = vector_2, Elemento5 = marco_2, Elemento6 = lista_1) # Visualización de la lista Mi_primera_lista ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento3 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $Elemento4 ## [1] TRUE FALSE TRUE ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 ## ## $Elemento6 ## $Elemento6$Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Elemento6$Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 Haciendo uso del operador [ ] # Selección del segundo elemento haciendo uso del operador [] - por posición Mi_primera_lista[2] ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # Selección del segundo elemento haciendo uso del operador [] - por nombre # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Elemento_2&#39; Elemento_2 &lt;- Mi_primera_lista[c(&#39;Elemento2&#39;)] Elemento_2 ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # Verificar la estructura de datos del elemento seleccionado - función class() class(Elemento_2) ## [1] &quot;list&quot; Haciendo uso del operador [[ ]] # Selección del quinto elemento haciendo uso del operador [[ ]] - por posición Mi_primera_lista[5] ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Selección del quinto elemento haciendo uso del operador [[ ]] - por nombre # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Elemento_5&#39; Elemento_5 &lt;- Mi_primera_lista[[&#39;Elemento5&#39;]] Elemento_5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Verificar la estructura de datos del elemento seleccionado - función class() class(Elemento_5) ## [1] &quot;data.frame&quot; Haciendo uso del operador $ # Selección del sexto elemento haciendo uso del operador $ - por nombre # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Elemento_6&#39; Elemento_6 &lt;- Mi_primera_lista$Elemento6 Elemento_6 ## $Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Verificar la estructura de datos del objeto Elemento_6 - función class() # ¿Por qué el objeto resultante (Elemento_6) es una lista? class(Elemento_6) ## [1] &quot;list&quot; 2.6.4.1.2 Selección de más de un elemento de una lista La selección de más de un elemento contenido en una lista en R se da a través del uso del operador[] y dentro de este, acudiendo a vectores cuyos elementos pueden ser enteros positivos, enteros negativos, lógicos o de tipo caracter. Así mismo, la selección de más de un elemento de una lista, implica una lista como objeto resultante. Es decir, en una lista de R, a diferencia de lo que puede ocurrir al seleccionar un elemento, la selección de más de un elemento siempre arrojará como resultado una nueva lista. A continuación, haciendo uso de la lista Mi_primera_lista`, se presentan algunos ejemplos con la selección de dos o más elementos de una lista haciendo uso de vectores con diversas tipologías. Ejemplo. Selección de más de un elemento de una lista de R # Creación de variables/elementos para la lista vector_1 &lt;- c(1, 2, 3, 4) matriz_1 &lt;- matrix(c(1:4), nrow=2, byrow = TRUE) marco_1 &lt;- head(iris) vector_2 &lt;- c(TRUE, FALSE, TRUE) marco_2 &lt;- tail(mtcars) lista_1 &lt;- list(Letras = LETTERS[c(1:5)], Matriz = matrix(c(1:9), nrow=3)) # Creación de la lista Mi_primera_lista &lt;- list(Elemento1 = vector_1, Elemento2 = matriz_1, Elemento3 = marco_1, Elemento4 = vector_2, Elemento5 = marco_2, Elemento6 = lista_1) # Visualización de la lista Mi_primera_lista ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento3 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $Elemento4 ## [1] TRUE FALSE TRUE ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 ## ## $Elemento6 ## $Elemento6$Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Elemento6$Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 Haciendo uso de vectores con enteros negativos # Selección del primer elemento Mi_primera_lista[-c(2:6)] ## $Elemento1 ## [1] 1 2 3 4 # Selección del segundo y del cuarto elemento # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Negativos_1&#39; Negativos_1 &lt;- Mi_primera_lista[c(-1, -3, -5, -6)] Negativos_1 ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento4 ## [1] TRUE FALSE TRUE # Verificar la estructura de datos del objeto Negativos_1 - función class() class(Negativos_1) ## [1] &quot;list&quot; Haciendo uso de vectores con enteros positivos # Selección de los elementos 3 y 5 Mi_primera_lista[c(3, 5)] ## $Elemento3 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Selección de los elementos 1, 4 y 6. # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Positivos_1&#39; Positivos_1 &lt;- Mi_primera_lista[c(1, 4, 6)] Positivos_1 ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento4 ## [1] TRUE FALSE TRUE ## ## $Elemento6 ## $Elemento6$Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Elemento6$Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Verificar la estructura de datos del objeto Positivos_1 - función class() class(Positivos_1) ## [1] &quot;list&quot; Haciendo uso de vectores con elementos lógicos # Selección de los elementos 2, 4 y 5 Mi_primera_lista[c(FALSE, TRUE, FALSE, TRUE, TRUE, FALSE)] ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento4 ## [1] TRUE FALSE TRUE ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Selección de los elementos 1, 3 y 5. # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Logicos_1&#39; # Aplicando la regla de reciclaje de elementos Logicos_1 &lt;- Mi_primera_lista[c(TRUE, FALSE)] Logicos_1 ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento3 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Verificar la estructura de datos del objeto Logicos_1 - función class() class(Logicos_1) ## [1] &quot;list&quot; Haciendo uso de vectores con elementos textuales (cadena o caracter) # Selección de los elementos cuyos nombres son Elemento2 y Elemento5 Mi_primera_lista[c(&#39;Elemento2&#39;, &#39;Elemento5&#39;)] ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento5 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 # Selección de los elementos cuyos nombres son Elemento1, Elemento2 y Elemento6. # Guardar e imprimir los resultados a partir de un objeto llamado &#39;Textos_1&#39; Textos_1 &lt;- Mi_primera_lista[c(&#39;Elemento1&#39;, &#39;Elemento2&#39;, &#39;Elemento6&#39;)] Textos_1 ## $Elemento1 ## [1] 1 2 3 4 ## ## $Elemento2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## ## $Elemento6 ## $Elemento6$Letras ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $Elemento6$Matriz ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Verificar la estructura de datos del objeto Textos_1 - función class() class(Textos_1) ## [1] &quot;list&quot; 2.6.4.2 Otras actividades con listas La gestión de listas en R, al igual que los marcos de datos o data.frame, implican la realización de un número importante de actividades sobre sus elementos entre las que se destacan, entre otras, la asignación o el cambio de los nombres, la modificación del contenido y la adición y eliminación de los mismos. A continuación, se presentan algunos ejemplos con parte de las principales actividades aplicables a la gestión de listas las cuales, dado el alcance de este documento, se presentan de manera general. El desarrollo de estos ejemplos, como se puede deducir, se soportan en el conocimiento requerido para la gestión de marcos de datos o data.frame y que se presentó en la sección anterior. Si se considera necesario, invitamos al lector a explorar nuevamente este contenido y, en especial, a revisar los apartados relacionadas con la modificación y eliminación de variables en data.frame y con la adición de elementos en estas estructuras de datos. Ejemplo. Actividades frecuentes en la gestión de listas con R # Crear lista llamada Milista_2 # No se le asignó nombres a los elementos Milista_2 &lt;- list(c(1, 2, 3, 4, 6), matrix(c(1:9), byrow = TRUE, nrow= 3, ncol = 3), head(mtcars, n = 5)) # Visualizar elementos de Milista_2 # Revisar como identifica R, en el output, cada uno de los elementos de Milista_2 Milista_2 ## [[1]] ## [1] 1 2 3 4 6 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## [[3]] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Asignar o modificar nombres de elementos de una lista # Asignar nombres a la lista Milista_2 # Hacer uso de la función names() names(Milista_2) &lt;- c(&#39;Nomb_1&#39;, &#39;Nomb_2&#39;, &#39;Nomb3&#39;) # Mostrar lista con nombres asignados Milista_2 ## $Nomb_1 ## [1] 1 2 3 4 6 ## ## $Nomb_2 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## $Nomb3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 # modificar el nombre del tercer elemento (Nomb3) por Nomb_3 names(Milista_2)[3] &lt;- c(&#39;Nomb_3&#39;) # Mostrar lista con el nombre del tercer elemento modificado Milista_2 ## $Nomb_1 ## [1] 1 2 3 4 6 ## ## $Nomb_2 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## $Nomb_3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Modificar contenido de elementos de una lista # Modificar contenido de elementos (reemplazar) # cambiar el elemento de la lista llamado &#39;Nomb_1&#39; por el vector c(5, 7:9, 11) # ¿Por qué se necesita usar corchetes dobles? Milista_2[[c(&#39;Nomb_1&#39;)]] &lt;- c(5, 7:9, 11) # Mostrar lista con elemento reemplazado Milista_2 ## $Nomb_1 ## [1] 5 7 8 9 11 ## ## $Nomb_2 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## $Nomb_3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 # Modificar contenido de elementos (modificar) # Modificar los elementos 1 y 5 del elemento Nomb_1 de la lista # Analizar cómo R desarrolla este ejercicio Milista_2[[c(&#39;Nomb_1&#39;)]][c(1, 5)] &lt;- c(6, 10) # Mostrar lista con elemento modificado Milista_2 ## $Nomb_1 ## [1] 6 7 8 9 10 ## ## $Nomb_2 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## $Nomb_3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Adicionar elementos a una lista # Adiciconar un nuevo elemento llamado Nomb_4 a la lista # La lista ahora cuenta con 4 elementos # ¿Qué tiene de especial este nuevo elemento Milista_2$Nomb_4 &lt;- list(a = seq(1, 10, 2), b = matrix(c(1:4), ncol = 2)) # Mostrar lista con nuevo elemento Milista_2 ## $Nomb_1 ## [1] 6 7 8 9 10 ## ## $Nomb_2 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ## $Nomb_3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## ## $Nomb_4 ## $Nomb_4$a ## [1] 1 3 5 7 9 ## ## $Nomb_4$b ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Eliminar elementos de una lista # Eliminar los elementos de la lista llamados &#39;Nomb_1&#39; y &#39;Nomb_2&#39; Milista_2[c(&#39;Nomb_1&#39;, &#39;Nomb_2&#39;)] &lt;- NULL # Mostrar lista con elementos modificados Milista_2 ## $Nomb_3 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## ## $Nomb_4 ## $Nomb_4$a ## [1] 1 3 5 7 9 ## ## $Nomb_4$b ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Los anteriores ejemplos, que hacen parte de la cotidianidad de la gestión con listas en R, en un principio pueden resultar complejos de entender y desarrollar dado el tiempo de comprensión que probablemente estos exigen de cada uno de nosotros. Por lo anterior, invitamos a los lectores a complementar el conocimiento de lo expuesto en esta sección dadas las limitaciones anunciadas y el alcance esperado con el desarrollo del presente documento. 2.6.5 Factores A lo largo de esta sección del documento hemos presentado, con menor o mayor profundidad, las características de las principales estructuras de datos que conforman la base del lenguaje de programación estadístico R (vectores, matrices, marcos de datos o data.frame y listas). En R base, existe una sexta característica del lenguaje la cual resulta de alta útilidad en la gestión y análisis de datos, conocida como factores. Los factores, aunque no son considerados como una estructuta de datos propia del lenguaje, están orientados a facilitar el trabajo con variables de tipo categórico o nominal y de tipo ordinal. Aunque este texto no está orientado a la metodología de la investigación, en la práctiva investigativa e incluso en el contexto de la gestión empresarial a nivel público o privado, es común el trabajo con variables las cuales pueden ser clasificadas, desde una perspectiva metodológica, en tres categorías42: continuas (intervalo o razón), nominales o categóricas y ordinales. Las variables de intervalo hacen parte del subconjunto de variables continuas y se diferencian de las variables de razón, que también pertenecen a este subconjunto, en la inexistencia de un cero absoluto. Por ejemplo, la temperatura del ambiente es un ejemplo de variable de intervalo porque 0 grados no significa ausencia de temperatura. En contraste, la velocidad de un vehículo, es un ejemplo de una variable de razón porque 0 sí significa ausencia de velocidad -el vehículo se encuentra detenido-. Las variables nominales o categóricas se caracterizan por “medir” las cualidades de un atributo de interés -un número limitado-. Estas pueden hacer uso o no de números, pero carece de sentido realizar con estos las operaciones aritméticas básicas pues los mismos juegan un rol exclusivo de identificación. Las variables ordinales, de manera semejante y a diferencia de las nominales, permiten la identificación de una o más cualidades de un individuo pero a diferencia de las nominales, en estas existe un orden entre las modalidades de la variable. Por ejemplo, el sexo o el estado civil de una persona son ejemplos de varaibles de tipo nominal pues estas están conformadas por cualidades en donde el orden de las mismas carece de sentido. El status social de una persona (bajo, medio o alto) o el nivel de satisfacción de un usuario con un servicio (malo, regular, bueno o excelente) son ejemplos de variales de tipo ordinal en donde las cualidades, además de representar una característica de interés, presentan un orden en su magnitud: malo es peor que regular, regular es peor que bueno y bueno es peor que excelente, por ejemplo. Para una gestión correcta de variables de tipo nominal u ordinal en R, es aconsejable el uso de factores. A continuación, se presenta la regla general para la construcción de factores en R. Regla: Construcción de factores en R En R, los factores se construyen haciendo uso de la función factor(). Esta función está compuesta por un conjunto de argumentos requeridos para una correcta gestión de variables nominales u ordinales. A continuación, a través del desarrollo de un ejemplo, se presentan las principales características asociadas a la gestión de factores en R. Para ello, supongamos que estamos interesados en conocer el total de personas que pertenecen a cada uno de los grupos sanguíneos existentes (O, A, B Y AB) a partir de los resultados observados en una muestra de 10 individuos. El grupo sanguíneo al que pertenece cada uno de los individuos del ejemplo está contenido en un vector llamado Grupo_S cuyos valores son c('O', 'A', 'B', 'O', 'A', 'O', 'O', 'A', 'B', 'O') y la tabla con el total de los individuos que conforman cada grupo será calculada a través del uso de una función disponible en R llamada table()43. Los resultados de los grupos sanguíneos44 al que pertenecen cada uno de los individuos del ejemplo están contenidos dentro de un vector de tipo cadena o caracter y a partir de estos, sin el uso de factores, se puede dar respuesta a la pregunta de interés: ¿cuántos individuos pertenecen acada uno de los grupos sanguíneos actualmente existentes? A continuación, se presenta el desarrollo del ejercicio sin acudir al uso de factores. Ejemplo. Construcción de tablas a partir de vectores de tipo cadena o caracter (textuales). # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Visualizar los resultados Grupo_S ## [1] &quot;O&quot; &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; &quot;O&quot; # Verificar el tipo de vector que contiene los resultados class(Grupo_S) ## [1] &quot;character&quot; # Construir una tabla con el total de invividuos por grupo sanguíneo table(Grupo_S) ## Grupo_S ## A B O ## 3 2 5 Al observar los resultados del ejemplo anterior podemos concluir que existen tres individuos que pertenecen al grupo sanguíneo A, 2 al grupo sanguíneo B y 5 al grupo sanguíneo O. Con esta forma de proceder, desde luego, estamos dando una respuesta a la pregunta de interés. No obstante, si quisieramos ser más precisos en nuestra respuesta, ninguno de los individuos pertenece al grupo sanguíneo AB y en la tabla de respuesta esta característica no fue tenida en cuenta. En esta situación y en otras como: el caso en el que deseemos renombrar las opciones de respuesta de una variable categórica, ordenar la presentación de los resultados de una variable categórica o señalar que sus opciones tienen un orden natural definido (variables ordinales), resulta de alta utilidad gestionar este tipo de variables acudiendo al uso de de factores. 2.6.5.1 Crear factores en R La primera forma disponible para crear factores en R es haciendo uso de la función factor() sin argumentos; es decir, únicamente con la variable que se desea transformar como un factor. A continuación, se presenta la creación de un factor a través de esta vía a partir de la variable disponible con el ejemplo de los grupos sanguíneos. Ejemplo. Creación de factores por defecto en R # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Crear la variable como un factor a través del uso de la función factor() # Almacenar los resultados en una variable llamada Grupo_S_factor Grupo_S_factor &lt;- factor(Grupo_S) # Visualizar los resultados del objeto Grupo_S_factor Grupo_S_factor ## [1] O A B O A O O A B O ## Levels: A B O # Verificar el tipo de objeto que contiene los resultados class(Grupo_S_factor) ## [1] &quot;factor&quot; # Ver las características de la variable transformada - función str() str(Grupo_S_factor) ## Factor w/ 3 levels &quot;A&quot;,&quot;B&quot;,&quot;O&quot;: 3 1 2 3 1 3 3 1 2 3 # Construir una tabla con el total de invividuos por grupo sanguíneo # Haciendo uso de una variable convertida en factor table(Grupo_S_factor) ## Grupo_S_factor ## A B O ## 3 2 5 Al analizar los resultados anteriores podemos observar varios aspectos de suma importancia a la hora de gestionar variables en R haciendo uso de factores. En primer lugar, al visualizar los resultados del objeto Grupo_S_factor este, además de presentar los resultados del vector, viene acompañado de una nueva línea Levels: A B O en donde se nos anuncia que nuestra variable es de tipo factor y que esta está conformada por tres niveles (A, B y O) los cuales se presentan, por defecto, en orden alfabético. En segundo lugar, al aplicar la función class() al objeto creado, se corrobora que este es de naturaleza/tipo factor. En tercer lugar, la función str() nos presenta una perspectiva más elaborada de las características del factor en cuestión: es un factor (Factor), está conformado por tres niveles (“A”,“B”,“O”) e internamente se están representando los niveles/modalidades a través de números enteros (1 para A, 2 para B y 3 para O). En cuarto lugar, la tabla de frecuencias extraida a partir d ela función table() nos presenta los mismos resultados obtenidos en el ejercicio anterior: 3 individuos pertenecen al grupo sanguíneo A, 2 al grupo sanguíneo B y 5 al grupo sanguíneo O. En términos generales, más allá del uso de factores, no se observa una diferencia importante aún entre la representación de variables categóricas como vectores de tipo caracter o la representación de estas haciendo uso de factores. No obstante, como veremos a continuación, el uso de factores resulta de suma importancia cuando una opción de respuesta de una variable categórica no se encuentra contenida en ninguno de los individuos bajo estudio pero aún así deseamos informar de esta condición o cuando se desea que los resultados (niveles) se presenten en un orden particular. Por ejemplo, en el caso de los grupos sanguíneos, estamos interesados que el resultado despliegue una respuesta para el grupo sanguíneo AB a pesar de que ninguno de los individuos de la muestra pertecene a este grupo. Así mismo, resulta de interés que estos se deslieguen/presenten de acuerdo a la prevalencia mundial existente: el grupo sanguíneo más frecuente es el O, luego el A, luego el B y, finalmente, el grupo sanguíneo más escaso es el AB45. A continuación, se presenta la forma como R nos permite obtener estos dos propósitos acudiendo al uso de factores. 2.6.5.2 Ajustar la cantidad y el orden de los niveles de un factor Para ajustar la cantidad de niveles o modalidades existentes en una variable categórica a través del uso de factores en R o para ordenar la forma como estos deben ser presentados en los resultados, acudimos al uso, dentro de la función factor() del argumento levels. A continuación, haciendo uso del ejemplo de grupos sanguíneos, se presenta la forma como R permite adicionar niveles/modalidades a una variable categórica así como reordenar el orden de estos. Ejemplo. Ajustar la cantidad y el orden de los niveles de un factor # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Crear la variable como un factor a través del uso de la función factor() # Hacer uso del argumento levels # Almacenar los resultados en una variable llamada Grupo_S_factor_1 Grupo_S_factor_1 &lt;- factor(Grupo_S, levels = c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;AB&#39;)) # Visualizar los resultados del objeto Grupo_S_factor_1 Grupo_S_factor_1 ## [1] O A B O A O O A B O ## Levels: O A B AB # Verificar el tipo de objeto que contiene los resultados class(Grupo_S_factor_1) ## [1] &quot;factor&quot; # Ver las características de la variable transformada - función str() str(Grupo_S_factor_1) ## Factor w/ 4 levels &quot;O&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;: 1 2 3 1 2 1 1 2 3 1 # Construir una tabla con el total de invividuos por grupo sanguíneo # Hacer uso de la función table() table(Grupo_S_factor_1) ## Grupo_S_factor_1 ## O A B AB ## 5 3 2 0 Al observar los resultados del ejemplo anterior podemos constatar que se han cumplido las pretensiones buscadas y en ellas a resultado fundamental el uso de factores. En primer lugar, se ha creado una variable con el total de niveles existentes en la realidad sin importar que estos no estén disponibles en la muestra de individuos hecho que permitió mostrar que no existe ningún individuo (cero) perteneciente al grupo sanguíneo AB; así mismo, se ingresó de manera manual y no por defecto el orden de presentación de los niveles de una variable categórica hecho que permitió, en el ejemplo de grupos sanguíneos, disponer/presentar los resultados de acuerdo a la prevalencia mundial (O, A, B y AB). 2.6.5.3 Renombrar los niveles de un factor La última característica útil para la gestión de variables nominales o categóricas a través de la disposición/uso de factores en R es la capacidad disponible en esta función para renombrar los niveles/modalidades existentes. Por ejemplo, supongamos que estamos interesados en usar una etiqueta alternativa (renombrar) para cada uno de los grupos sanguíneos del ejemplo de tal manera que el grupo sanguíneo O se llame Grupo O, el grupo sanguíneo A se llame Grupo A, el grupo sanguíneo B se llame Grupo B y, finalmente, el grupo sanguíneo AB se llame Grupo AB. Para ello, en R existen dos alternativas de solución: haciendo uso del argumento labels dentro de la función factor() o acuendiendo a la función levels cuando se dispone de un factor y se desean modificar sus niveles. A continuación, se presenta un ejemplo para cada una de las alternativas que ofrece este lenguaje para renombrar los niveles de un factor. Ejemplo. Renombrar niveles de un factor en R - primera alternativa # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Crear la variable como un factor a través del uso de la función factor() # Hacer uso del argumento levels y labels # Almacenar los resultados en una variable llamada Grupo_S_factor Grupo_S_factor &lt;- factor(Grupo_S, levels = c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;AB&#39;), labels = c(&#39;Grupo A&#39;, &#39;Grupo B&#39;, &#39;Grupo O&#39;, &#39;Grupo AB&#39;)) # Visualizar los resultados del objeto Grupo_S_factor Grupo_S_factor ## [1] Grupo A Grupo B Grupo O Grupo A Grupo B Grupo A Grupo A Grupo B Grupo O ## [10] Grupo A ## Levels: Grupo A Grupo B Grupo O Grupo AB # Ver las características de la variable transformada - función str() str(Grupo_S_factor) ## Factor w/ 4 levels &quot;Grupo A&quot;,&quot;Grupo B&quot;,..: 1 2 3 1 2 1 1 2 3 1 # Construir una tabla con el total de invividuos por grupo sanguíneo # Hacer uso de la función table() table(Grupo_S_factor) ## Grupo_S_factor ## Grupo A Grupo B Grupo O Grupo AB ## 5 3 2 0 Ejemplo. Renombrar niveles de un factor en R - segunda alternativa # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Crear la variable como un factor a través del uso de la función factor() # Hacer uso del argumento levels # Almacenar los resultados en una variable llamada Grupo_S_factor_1 Grupo_S_factor_1 &lt;- factor(Grupo_S, levels = c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;AB&#39;)) # Visualizar los resultados del objeto Grupo_S_factor_1 Grupo_S_factor_1 ## [1] O A B O A O O A B O ## Levels: O A B AB # Renombrar los niveles del factor Grupo_S_factor_1 # Hacer uso de la función levels levels(Grupo_S_factor_1) &lt;- c(&#39;Grupo O&#39;, &#39;Grupo A&#39;, &#39;Grupo B&#39;, &#39;Grupo AB&#39;) # Visualizar los resultados del objeto Grupo_S_factor_1 modificado - renombrado Grupo_S_factor_1 ## [1] Grupo O Grupo A Grupo B Grupo O Grupo A Grupo O Grupo O Grupo A Grupo B ## [10] Grupo O ## Levels: Grupo O Grupo A Grupo B Grupo AB # Ver las características de la variable modificada - función str() str(Grupo_S_factor_1) ## Factor w/ 4 levels &quot;Grupo O&quot;,&quot;Grupo A&quot;,..: 1 2 3 1 2 1 1 2 3 1 # Construir una tabla con el total de invividuos por grupo sanguíneo # Hacer uso de la función table() table(Grupo_S_factor_1) ## Grupo_S_factor_1 ## Grupo O Grupo A Grupo B Grupo AB ## 5 3 2 0 En la primera alternativa, se partió de un vector de tipo cadena o caracter, se hizo uso de la función factor() y dentro de esta, de los argumentos levels y labels para definir, respectivamente, los niveles requeridos con su respectivo orden y el renombramiento de estos. En contraste, la alternativa 2, partió de un factor creado haciendo uso de la función factor() y, dentro de esta, acudiendo al argumento levels; paso seguido, se procedió a modificar el contenido de los niveles previamente creados a través del uso de la función levels()46. 2.6.5.4 Variables ordinales Las variables nominales o categóricas, por su naturaleza, no presentan un orden natural entre sus modalidades u opciones de respuesta. Este hecho implica que carezca de sentido y sea imposible comparar si una condición observada en una variable para un individuo es menor o mayor que la misma condición observada en otro individuo. Por ejemplo, si retomamos el ejercicio que hemos venido trabajando a lo largo de este numeral del documento, el de la información de grupos sanguíneos para una muestra de 10 individuos y si estamos interesados en comparar, por ejemplo, si el grupo sanguíneo del individuo ubicado en la posición 1 es menor (&lt;) que el grupo sanguíneo del individuo ubicado en la posición 2 el lenguaje, como se muestra a continuación, retornará un dato faltante. Es decir, R no reconoce si esta condición es verdadera o falta y por este motivo retorna el dato NA. Ejemplo. Orden en variables nominales haciendo uso de factores # Definir el vector con información de grupos sanguíneos Grupo_S &lt;- c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;O&#39;) # Crear la variable como un factor a través del uso de la función factor() # Hacer uso del argumento levels # Almacenar los resultados en una variable llamada Grupo_S_factor_1 Grupo_S_factor &lt;- factor(Grupo_S, levels = c(&#39;O&#39;, &#39;A&#39;, &#39;B&#39;, &#39;AB&#39;)) # Verificar si el grupo sanguíneo del individuo 1 (O) es menor que # el grupo sanguíneo del individuo 2 (A) Grupo_S_factor[1] &lt; Grupo_S_factor[2] ## Warning in Ops.factor(Grupo_S_factor[1], Grupo_S_factor[2]): &#39;&lt;&#39; not meaningful ## for factors ## [1] NA Al observar los resultados del ejemplo anterior el lenguaje, ante la comparación requerida, retornó un Warning o mensaje de advertencia e imprimió un NA como respuesta. Es decir, no existe información suficiente para poder decir que el grupo sanguíneo del individuo 1 es menor que el grupo sanguíneo del individuo 2. Desde luego, este resultado era esperable dado que estamos ante la presencia de una variable de tipo nominal o categórico y en estas carece de sentido definir un orden entre sus modalidades. Como se mencionó al inicio de esta sección, desde una perspectiva de la metología de la investigación, un subconjunto de las variables existentes está constituido por las variables ordinales. Es decir, aquellas que están conformadas por modalidades de respuesta -igual que las variables categóricas-, pero que presentan un orden natural entre sus modalidades: bajo, medio, alto; poco, regular, mucho; pequeño, mediano, grande; etc. Para gestionar variables de naturaleza ordinal en R, se debe definir en el código del lenguaje que la variable que estamos gestionando es de tipo ordinal y esto se logra haciendo uso, dentro de la función factor(), del argumento ordered = TRUE. Por ejemplo, supongamos que contamos con la información del peso de 7 individuos clasificado en bajo, medio y alto y que esta se encuentra contenida en un vector llamado Peso cuyo contenido es c('Bajo', 'Bajo', 'Medio', 'Alto', 'Alto', 'Medio', 'Alto'). Así mismo, supongamos que estamos interesados en construir una tabla de frecuencias con la cantidad de individuos por cada opción de respuesta y comparar si el peso del individuo 4 es mayor al del individuo 1. A continuación, se presenta el desarrollo de este ejercicio. Ejemplo. Factores y variables ordinales en R # Definir el vector con información de pesos de personas Peso &lt;- c(&#39;Bajo&#39;, &#39;Bajo&#39;, &#39;Medio&#39;, &#39;Alto&#39;, &#39;Alto&#39;, &#39;Medio&#39;, &#39;Alto&#39;) # Crear la variable Peso como un factor - renombrar # Hacer uso del argumento levels para definir el orden de los niveles # Hacer uso del argumento ordered para anunciar que es de tipo ordinal Peso &lt;- factor(Peso, levels = c(&#39;Bajo&#39;, &#39;Medio&#39;, &#39;Alto&#39;), ordered = TRUE) # Visualizar los resultados del objeto Peso Peso ## [1] Bajo Bajo Medio Alto Alto Medio Alto ## Levels: Bajo &lt; Medio &lt; Alto # Verificar el tipo de objeto que contiene los resultados class(Peso) ## [1] &quot;ordered&quot; &quot;factor&quot; # Ver las características de la variable Peso - función str() str(Peso) ## Ord.factor w/ 3 levels &quot;Bajo&quot;&lt;&quot;Medio&quot;&lt;..: 1 1 2 3 3 2 3 # Construir una tabla con el total de invividuos por grupos de peso # Hacer uso de la función table() table(Peso) ## Peso ## Bajo Medio Alto ## 2 2 3 # Verificar si el peso del individuo 4 (Alto) es mayor que el peso del individuo 1 (Bajo) Peso[4] &gt; Peso[1] ## [1] TRUE Los resultados del ejemplo anterior muestran la forma y las características de la gestión de variables ordinales en R. A través del ejemplo expuesto es posible determinar que la variable analizada es de tipo ordinal hecho que se corrobora al observar varios aspectos. En primer lugar, los niveles de la variable ordinal Peso, a diferencia del caso de variables categóricas, ahora presenta un orden Levels: Bajo &lt; Medio &lt; Alto, así mismo, las funciones class() y str() nos permiten corroborar que la variable bajo estudio es de tipo ordinal \"ordered\" \"factor\" y Ord.factor w/ 3 levels \"Bajo\"&lt;\"Medio\"&lt;, respectivamente. En segundo lugar, la tabla de frecuencias construida con la función table() presenta la información de manera ordenada de acuerdo al orden definido para los respectivos niveles levels = c('Bajo', 'Medio', 'Alto'). Finalmente y a diferencia de lo observado en el caso de variables categóricas, en el escenario de las variables ordinales, es posible comparar si el valor observado en un individuo es mayor o menor que el observado en otro. Por ejemplo, el peso del individuo 4 del ejemplo anterior es mayor que el peso del individuo 1 -TRUE como respuesta a la instrucción Peso[4] &gt; Peso[1]-. Al final de esta sección, se presenta una “estructura” especial de datos la cual,en sentido estricto, no presenta las mismas características que las demás estructuras presentadas en este documento↩︎ Un número escalar hace referencia a una estructura conformada por un único número. Por ejemplo, 3, 4 -5 o 7, son ejemplos de escalares en otros lenguajes de programación↩︎ En R, la presencia de vectores en cuyo interior se presentan elementos de diversas tipologías se debe, principalmente, a la presencia de probables errores en la creación/inserción de estos que, por ejemplo, a una característica recurrente y propia del análisis de datos.↩︎ hasta tanto el usuario no disponga de experiencia y conocimiento sobre ciertas funciones de R, se recomienta que al invocar estas siempre se coloque el nombre de cada uno de los parámetros utilizados↩︎ Invitamos al lector a imaginar y entender lo que el lenguaje está haciendo al momento de evaluar las operaciones entre vectores existentes en este ejemplo↩︎ La longitud de un vector en R puede ser explorada/conocida a través de la función length(). Por ejemplo, al implementar la siguiente instrucción en R length(c(1:5)), el resultado será 5 que es equivalente a la cantidad de elementos que contienen el vector dado↩︎ Al implementar operaciones lógicas entre vectores que combinan operadores relacionales y lógicos, aplica la regla de precedencia o priorización para este tipo de operadores y que fue presentada en la sección 2.5. Primero se evaluan las operaciones con vectores que implican operadores relacionales y luego las que implican operadores lógicos↩︎ El tamaño de un vector hace referencia a la cantidad de elementos que este contiene. Por ejemplo, el tamaño o longitud del vector c(1, 3, 4, 5) es igual a 4 (cantidad de elementos)↩︎ En este documento, dado su alcance, nos concentraremos en las primeras cuatro posibilidades; es decir, no serán tenidas en cuenta las opciones ninguno (nothing) y cero (zero), de poca utilidad o uso en el análisis de datos↩︎ La cuarta opción, basada en vectores de tipo caracter, será presentada en la sección siguiente↩︎ Esta característica resulta útil al momento de extraer elementos de un vector con una gran cantidad de elementos siempre y cuando los elementos a ser seleccionados presenten una sucesión/ciclo útil en la práctica↩︎ Esta no es la única forma que ofrece el lenguaje para la construcción de matrices. No obstante, es la forma convencional que ofrece R para la construcción de este tipo de estructuras↩︎ Más adelante se presentarán de manera formal lo que es una lista en R. Por el momento, aceptaremos que estas estructura de datos -las listas- nos permiten alojar más de un vector de datos↩︎ En el caso de que la cantidad de columnas requeridas multiplicada por la cantidad de filas, sea mayor a la cantidad de elementos disponibles, R, al igual que en el caso de vectores, recicla los elementos del vector de datos disponible hasta completar la matriz requerida↩︎ Este resultado es equivalente a haber implementado la línea de código M[c(2), c(3)] en razón a que en este lenguaje, como se mencionó en la segunda regla del capítulo de vectores, no existen escalares sino vectores de longitud 1↩︎ Si lo que se hubiese requerido es la selección de los elementos de la columna 4, la línea de código requerida es M[ , 4]↩︎ La selección de elementos de una matriz haciendo uso de vectores de tipo caracter, requiere que las filas y las columnas de la matriz hayan sido nombradas (tengan nombres)↩︎ En R, como se presentará más adelante, es posible y común, construir funciones por parte de los usuarios para propósitos particulares.↩︎ En R, existen cientos de funciones para la gestión de matrices las cuales exigen del usuario, además de una correcta gestión de las mismas, conocer cuáles de ellas resultan útiles para los propósitos deseados.↩︎ Una función en R puede ser útil para más de una estructura de datos. Por ejemplo, la función class() que se usa para determinar el tipo de estructura que contiene un conjunto de datos puede usarse en vectores, matrices o cualquier otro tipo de objeto en R↩︎ En el componente de transformación de datos se explicará con mayor detalle el proceso de importación de datos en R desde fuentes externas y la conformación de data.frames como resultados de este proceso.↩︎ Este marco de datos hace parte de una librería llamada datasets la cual, además de hacer parte de las librerías instaladas por defecto en el lenguaje, contiene un número importante de conjuntos de datos data.frame útiles para ser usados como ejemplos en en el proceso de aprendizaje o experimentación con este lenguaje. Si se desea conocer los conjuntos de datos disponibles dentro de esta librería, basta con invocar y compilar en la consola o en el editor de Rstudio la funcion data().↩︎ Auque ambas formas conducen al mismo resultado, se recomienda usar la forma que contiene a su interior la coma pues esta da la idea de separación entre los individuos de un data.frame y sus variables -a la izquierda de la coma del operador se ubican los individuos [Individuos , ] que se desea seleccionar y a la derecha las variables- [ , Variables].↩︎ En R existe una alternativa para la selección de individuos de un data.frame haciendo uso de vectores de tipo cadena o caracter (textuales). No obstante, dado el alcance de este documento, no se presentará esta alternativa pues ella implica tener claro cómo el lenguaje nombra/identifica a cada uno de los individuos que conforman un marco de datos.↩︎ Ninguna flor de la especie versicolordel conjunto de datos iris tiene una longitud del sépalo igual o superior a 7.3↩︎ Los elementos de estos vectores pueden estar conformados por enteros positivos, enteros negativos, elementos lógicos o elementos de tipo caracter↩︎ En el caso de modificación de elementos ubicados en diferentes variables, como se muestra en uno de los ejemplos, se debe acudir al uso de listas en R. Las características y la conformación de estas estructuras de datos se presenta en la sección de Listas de este documento.↩︎ Los elementos de estos vectores pueden ser enteros positivos, enteros negativos o lógicos↩︎ Estas funciones, como se mencionó en la sección de matrices, hacen parte de los paquetes instalados por defecto en el lenguaje. Es decir, no requieren invocar o instalar nuevas librerías pues ellas se cargaron al momento de instalar por primera vez R en nuestras computadoras.↩︎ Además, las listas presentan algunas limitaciones y ciertos rasgos característicos frente a las demás estructuras de datos que se han presentado en este capítulo. Por ejemplo, en las listas, no aplica la regla de coerción de elementos la cual sí aplica para los vectores, las matrices, los arreglos y las variables de un data.frame↩︎ Desde una perspectiva filosófica, una lista es equivamente a un vector compuesto por elementos los cuales, a diferencia de los vectores hasta ahora vistos que exigen una misma tipología, pueden ser de diversos tipos. De hecho en R, desde una pespectiva conceptual, el conjunto de los vectores está conformado por dos subconjuntos: el de los vectores de naturaleza atómica y el de las listas. El subconjunto de los vectores atómicos está conformado por los vectores presentados en la sección de vectores de este capítulo↩︎ En el el caso de que no se le asigne un nombre a los elementos de una lista, las posiciones de estos en el output de R pueden ser identificados a través de corchetes dobles. Por ejemplo, el primero de los elementos se ubica en la posición [[1]], el segundo en la posición [[2]], y así sucesivamente.↩︎ Esta propuesta de clasificación de las tipologías de las variables es una de varias existentes en el contexto de la metodología de la la investigación. En nuestro criterio, esta forma de clasificar variables, es una de las más empleadas y de mayor utilidad para la gestión de datos y el análisis estadístico↩︎ A través de esta función es posible calcular en R el número de individuos que pertenecen a cada una de las modalidades de una variable de tipo categórico, nominal u ordinal↩︎ Una función de R que resulta útil para explorar el contenido de una variable categórica es la función unique(). A través de esta función es posible explorar la cantidad de opciones de respuesta disponibles dentro de una variable nominal o categórica.↩︎ Aproximadamente un 44% de la población mundial pertenece al grupo sanguieneo O, un 42% al grupo sanguíneo A, un 10% al grupo sanguíneo B y un 4% al grupo sanguíneo AB. Estas proporporciones cambian de manera importante si se incluye el RH; de hecho, se estima que el tipo de sangre AB- tan solo está presente en 1 de cada 67 personas (0.6%)↩︎ En R, existe una función llamada levels() y este nombre (levels) a su vez hace parte de uno de los argumentos de la función factor(). Es decir, en este lenguaje no existe ninguna restricción entre los nombres empleados para nombrar una variable y los empleados para nombrar sus argumentos. Como se acabá de presentar, estos pueden ser iguales (levels como función y levels como argumento)↩︎ "],
["3-Ejercicios.html", "Capítulo 3 Ejercicios", " Capítulo 3 Ejercicios En esta sección, se presenta un conjunto de ejercicios en R los cuales se iran presentando/asignando de manera periódica a lo largo del desarrollo del presente curso. Estos, están orientados a afianzar los conocimientos adquiridos en el proceso de aprendizaje y a fomentar su discusión en algunas de las sesiones virtuales del curso. "],
["3-1-trabajo-1.html", "3.1 Trabajo 1", " 3.1 Trabajo 1 ¿Qué regla aplica R para evaluar/desarrollar la operación aritmética compuesta (6/2*(2+1 + 2^3) + 24/(2*3 + 0^3) + 3)/8? Explicar, paso a paso y mediante varias líneas de comando, ¿cómo este lenguaje genera el resultado de la anterior operación? Escriba el número pi haciendo uso de la constante integrada pi, guarde su valor dentro de una variable llamada longitud circunferencia vs radio e imprima su resultado. Nota: el nombre de la variable debe respetar los espacios existentes entre las diferentes palabras. Escribra un dato de tipo lógico, almacene/guarde su contenido en una variable llamada Var%_1 e imprima su resultado. ¿Qué pasó al imprimir el resultado en R?, ¿Cómo arreglaría el problema generado para que imprima el resultado de manera correcta? Crear dos vectores en R con los números de 5 en 5: uno iniciando en 5 y terminando en 100 y el otro iniciando en 100 y terminando en 5. Es decir, c(5, 10, 15, 20, ... 100) y c(100, 95, 90, 85, ... 5). Cree en R, a partir de las funciones vistas para generar vectores de manera rápida (:, seq() o rep()), el siguiente vector c(“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “d”). Cree la variable var_1 y asigne a esta los elementos del vector c(1:10); luego cree la variable var_2 y asigne los elementos contenidos en el vector c(1, 0). Una vez se hayan creado los anteriores dos vectores, cree una nueva variable Rta y almacene allí la división entre los vectores var_1 y var_2. ¿Qué regla aplica R para realizar esta operación dado que los vectores son de diferente longitud? ¿Qué le llama la atención de los tipos de datos que genera esta división? ¿Qué explicación podría dar a los datos “raros” que esta operación genera? Cree la variable x y asigne a esta los elementos del vector c(10, 15, 20 , '30'); luego cree la variable y y asigne los elementos contenidos en el vector c(2, 5, '2', 10). Una vez se hayan creado los anteriores dos vectores, cree una nueva variable z y almacene allí la multiplicación entre los vectores x e y. ¿Por qué se genera un error al realizar la multiplicación entre los vectores x e y?, ¿qué regla está aplicando R a los elementos que conforman los vectores x e y antes de realizar la multiplicación? ¿Cómo solucionaria el problema generado por R para que se pueda implementar la multiplicación deseada? Nota: Copie el contenido de los vectores x e y directamente desde el ejercicio; es decir, no los ingrese manualmente a través del teclado. Cree en R un vector con los números del 1 al 100 y almacene el resultado en una variable llamada m. Haciendo uso de operadores relacionales, genere un vector lógico en donde TRUE contenga las posiciones de los elementos menores o iguales a 10 (&lt;= 10) que hacen parte del vector m. Cree la variable Números y asigne a esta los elementos del vector c('uno', 'tres', 'uno ', 'cuatro', ' uno', 'cinco', 'uno'). Haciendo uso de operadores lógicos de tipo relacional, cree una variable llamada Resultado y almacene allí un vector lógico con las posiciones en donde la variable Números es igual a la palabra uno, imprima los resultados contenidos en la variable Resultado. ¿Por qué algunos elementos del vector contenido en la variable Números, que tienen la palabra uno, no aparecen como TRUE en el vector lógico contenido en la variable Resultado? Realice los ajustes que considere pertinentes al vector Números para que la totalidad de los elementos que contienen la palabra uno aparezcan como TRUE en el vector lógico contenido en la variable Resultado. Nota: Copie el contenido del vector Números directamente desde el ejercicio; es decir, no los ingrese manualmente a través del teclado. Cree la variable var_1 y asigne a esta los elementos del vector seq(-5, 5, 1); luego cree la variable var_2 y asigne los elementos contenidos en el vector c(-5, 1, 2, -5, 3, 1, 0, -4, -5, 3, 1, -5). Implemente en R una expresión lógica que contenga las posiciones en donde los elementos de la variable var_1 son menores o iguales a cero y los elementos del vector var_2 son iguales a -5, 2 o -4. Nota: Investigue en la web el operador %in% en R y úselo si lo considera útil para desarrollar este ejercicio Cree la variable Serie y asigne a esta los números del 1 al 99 de dos en 2 (1, 3, 5, 7, ... , 99). Seleccione, haciendo uso del operador [ ] (corchetes), los elementos múltiplos de 5 contenidos en el vector Serie y almacene el resultado en una variable llamada Multiplo5. Imprima los resultados contenidos en la variable Multiplo5. ¿Por qué la variable Multiplo5 no genera un conflicto en R a pesar de que esta contiene un número en su nombre? Cree la variable Var en R y almacene en ella las primeras 5 letras del abecedario romano a partir de la constante integrada LETTERS. Cree, a partir de los elementos almacenados en la variable Var, una variable llamada Rep_Var con cada uno de los elementos contenidos en la variable Var de manera duplicada; es decir, \"A\" \"A\" \"B\" \"B\" \"C\" \"C\" \"D\" \"D\" \"E\" \"E\". Imprima los resultados de la variable Rep_Var. Nota: Los elementos de la variable Var no pueden ser ingresados desde el teclado; estos deben ser extraidos (un subconjunto) a partir del uso de la constante integrada LETTERS. Cree la variable Nueva y asigne a esta los elementos del vector c(11, 20, 15, 10); cree la variable Nombres y asigne a esta los elementos del vector c('xyz', 'c%2', 'mno', 'for'). Asigne a los elementos de la variable Nueva los nombres contenidos en la variable Nombres e imprima los resultados. Seleccione los elementos del vector contenido en la variable Nueva cuyos nombres son xyz y for. ¿Por qué cree que R no genera un error en los nombres de los elementos contenidos en el vector Nombres a pesar de que dos de ellos usan caracteres especiales del lenguaje R o palabras reservadas (c%2 y for)? "],
["3-2-trabajo-2.html", "3.2 Trabajo 2", " 3.2 Trabajo 2 Cree en R una matriz de 5 filas y 4 columnas, ingrese los datos por filas a través de un vector que contenga los numeros 10, 20, 30, …, 200. Cree el vector previamente mencionado haciendo uso de la función seq(). Guarde e imprimar los resultados de la matriz en una variable/objeto llamada Matriz_Ejer. Haciendo uso de la funciones rownames() y colnames() asígnele a la matriz creada en el ejercicio 1 Matriz_Ejer los nombres a las filas y a las columnas. Los nombres de las filas están contenidas en el vector c('Fila1', 'Fila2', 'Fila3', 'Fila4', 'Fila5') y los de las columnas en el vector c('Colum1', 'Colum2', 'Colum3', 'Colum4'). Imprima los resultados de la matriz Matriz_Ejer con los nombres asignados. Adicione a la matriz creada en el ejercicio 2 Matriz_Ejer, haciendo uso de la función rbind(), una nueva fila con los elementos c(210, 220, 230, 240). Luego, a la matriz resultante con la nueva fila, asígnele una nueva columna con los elementos c(50, 90, 130, 170, 210, 250). La matriz Matriz_Ejer ahora cuenta con 6 filas y 5 columnas; no obstante, la fila 6 y la columna 5 no tienen asignado un nombre. ¿Qué debemos hacer para asignarle el nombre Fila5 a la fila 5 y el nombre Colum5' a la columna 5 de la matriz Matriz_Ejer. Cree en R una matriz de 4 filas y 4 columnas, ingrese los datos por columnas a través de un vector construido haciendo uso de la función rep() de tal manera que la primera columna esté compuesta por unos (1), la segunda por doses (2), la tercera por treses (3) y la cuarta, por cuatros (4). Ingrese, al crear la anterior matriz y haciendo uso del argumento dimnames de la función matrix(), los nombres de las filas y las columnas los cuales deben ser, respectivamente, c('Fil1', 'Fil2', 'Fil3' y 'Fil4') y c('Co1', 'Col2', 'Col3' y 'Col4'). Almacene los resultados en una variable/objeto llamada Matriz_Rep. A partir de la matriz previamente creada Matriz_Rep, desarrolle las siguientes actividades. Seleccione la totalidad de elementos de la fila 1. Seleccione la totalidad de elementos de la columna 3. Seleccione el elemento ubicado en la fila 3 columna 4. Seleccione, haciendo uso de vectores con enteros positivos, las columnas 3 y 4. Seleccione, haciendo uso de vectores con elementos lógicos, los elementos ubicados en las filas 2 y 4. Seleccione, a través de una única consulta, los elementos ubicados en las intersecciones de las filas 1 y 3 y las columnas 1 y 4. Para el caso de las filas hacer uso de un vector con enteros negativos y para el caso de las columnas hacer uso de un vector de tipo caracter (textual). El conjunto de datos mtcars, al igual que el conjunto de datos iris y que se trabajó a lo largo del documento, hace parte de los marcos de datos data.frame que vienen incluidos por defecto en R desde el momento de su instalación47. Haciendo uso de las funciones class(), names(), dim(), length(), ncol(), nrow(), head(), tail(), str() y summary(), explorar el contenido del marco de datos mtcars. Selecionar la variable carb del conjunto de datos (data.frame) mtcars haciendo uso de los operadores [], [ , ], [[ ]] y $. ¿Existe alguna diferencia en el resultado al usar alguna de estas formas de extracción de una variable en R? Seleccionar las variables mpg, disp, drat, qsec, am y carb del conjunto de datos mtcars. El proceso de selección de estas variables debe realizarse a través de cuatro vías: haciendo uso de vectores con enteros positivos, haciendo uso de vectores con enteros negativos, haciendo uso de vectores con elementos lógicos y haciendo uso de vectores con datos de tipo caracter o textuales. Seleccionar, del conjunto de datos mtcars, los individuos con valores 4 o 6 en la variable cyl y cuyos valores en la variable mpg son mayores o iguales &gt;= a 25. Para estos individuos, retener la información de las variables mpg, cyl y carb. Guardar/almacenar e imprimir los resultados de este ejercicio en un objeto/variable llamado mtcars_new. Tomando como referencia el conjunto de datos mtcars, realizar las siguientes actividades. Cada uno de los ejercicios debe partir del conjunto de datos original; es decir, sin manipulaciones o ajustes previos del marco de datos mtcars. Para ello, iniciar el desarrollo de los siguientes ítems limpiando el Environment de Rstudio. Recomendación. Al inicio de cada uno de los ejercicios cree, a partir del conjunto de datos mtcars, el nuevo conjunto de datos con el nombre requerido. Por ejemplo, para el primero de los ejercicios que se presenta a continuación, se podrá crear el nuevo conjunto de datos haciendo uso de la línea de código mtcars_name &lt;- mtcars y sobre este nuevo set de datos realizar el ejercicio requerido. La misma recomendación aplica para el desarrollo de los demás ejercicios del presente numeral. Si presenta problemas en alguno de los ejercicios, limpiar el Environment de Rstudio y reiniciar su desarrollo. Cambiar los nombres de las variables hp, wt y am por los nombres hp_new, wt_new y am_new. Guarde e imprima los resultados con los nuevos nombres de las variables en un objeto llamado mtcars_name. Eliminar, haciendo uso de vectores, las variables drat, wt, qsec, vs, am, gear y carb. Guardar e imprimir los últimos 5 resultados del nuevo conjunto de datos en un objeto llamado mtcars_vec. Eliminar, haciendo uso del dato NULL, las variables mpg, cyl, disp y hp. Guardar e imprimir los resultados en un objeto data.frame llamado mtcars_nulos. Modificar/cambiar por 3.000 el valor de la variable wt del individuo ubicado en la posición 1 (fila 1). Guardar e imprimir los resultados de los primeros 5 individuos en un objeto llamado mtcars_modif. Eliminar, haciendo uso de vectores, los primeros 5 individuos. Guardar y presentar los primeros 10 resultados en un nuevo conjunto de datos llamado mtcars_ind2. Adicionar una nueva variable llamada New_Var con los valores 2, 4, 6, 8, … Guardar e imprimir los primeros 10 individuos en un objeto llamado mtcars_var_new. Adicionar un nuevo individuo al conjunto de datos mtcars. Seleccione los valores que a bien considere (aleatorios) para las 11 variables que conforman este conjunto de datos y requeridas para adicionar este nuevo individuo. Guardar e imprimir los resultados desde un objeto llamado mtcars_new_ind. Explorar, en la web, la utilidad de la función subset() de R e indagar si esta puede ser empleada para extraer, del conjunto de datos iris, las variables Sepal.Length, Petal.Length y Species de las flores cuya especie Species es igual a setosa. Si no es posible realizar la anterior consulta, explicar por qué? Estos conjuntos de datos hacen parte de una librería llamada datasets cuyos conjuntos de datos pueden ser explorados haciendo uso de la función data(). De igual manera, estos pueden ser descargados en formatos CSV desde la siguiente página web↩︎ "],
["3-3-trabajo-3.html", "3.3 Trabajo 3", " 3.3 Trabajo 3 Creen e imprima/visualice en R una lista llamada Lista que contenga los elementos contenidos en las siguientes variables. vec_1 &lt;- c(1:4, rep(1,3), 8:10) mat_1 &lt;- matrix(seq(0, 30, 2), nrow=4, ncol = 4) df_1 &lt;- tail(iris) df_2 &lt;- head(mtcars) lis_1 &lt;- list(Letras = LETTERS[c(1:5)], df_3 = data.frame(x = c(1:5), y = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;))) A partir de la lista previamente creada y llamada Lista, realice las siguientes actividades. Asigne los nombres a sus elementos. Los nombres de la lista están contenidos en el vector de tipo caracter c('vec_n1', 'mat_n1', 'df_n1', 'dfn2', 'lis_n1'). Cambie el nombre del elemento llamado 'dfn2' por 'df_n2'. Adicione un nuevo elemento a la lista llamado mat_n2 con la matriz matrix(c(TRUE, FALSE, TRUE, FALSE), ncol = 2, dimnames = list(c('F1', 'F2'), c('C1', 'C2'))). Imprima, haciendo uso de la función names(), los nombres de la lista resultante. Seleccione los elementos ubicados en las posiciones 1 y 3 haciendo uso de vectores con enteros negativos, enteros positivos, elementos lógicos y elementos de tipo caracter o textuales. Seleccione el elemento llamado 'df_n1' a través de dos formas. La primera, debe garantizar que se conserve la tipología original de la estructura de datos fuente; es decir, el elemento seleccionado debe continuar siendo una lista. La segunda, debe conservar la estructura del elemento seleccionado, es decir, un marco de datos o data.frame. Corrobore los resultados haciendo uso de la función class() Extraiga/seleccione la fila llamada F1 de la matriz mat_n2. Analizar detenidamente cómo obtener el resultado deseado. Este ejercicio presenta un nivel importante de complejidad. Extraiga/seleccione la variable y del marco de datos df_3 contenido dentro del elemento lis_1 de la lista; el contenido de la variable y debe estar alojado dentro de un data.frame conformado por 1 variable y 5 individuos. Analizar detenidamente cómo obtener el resultado deseado. Este ejercicio presenta un nivel importante de complejidad. Cambiar por 4 el valor actual del indiviudo 1 Mazda RX4 en la variable cyl ubicado dentro del elemento df_2 de la lista. Analizar detenidamente cómo obtener el resultado deseado. Este ejercicio presenta un nivel importante de complejidad. Eliminar los elementos de la lista llamados mat_n2 y vec_n1. Guarde los resultados en una nueva lista sin los elementos eliminados llamada Lista_Nueva El objetivo central del trabajo con factores, como se mencionó en la guía, es la gestión de variables de naturaleza categórica o nominal y ordinal. En general, estas variables se encuentran contenidas dentro de marcos de datos data.frameen R y a partir de la información contenida en estas estructuras, se deben gestionar las variables categóricas u ordinales de acuerdo a los intereses deseados. A continuación, se presentan un conjunto de datos data.frame hipotético conformado por 10 individuos y 5 variables. La primera de las variables, llamada Nombre, contiene los nombres de cada uno de los individuos; la segunda variable, llamada Edad, contiene la edad de los individuos; la tercera variable, llamada Social, contiene la condición social de cada individuo; la cuarta variable, llamada Sexo, contienen el sexo biológico de cada uno de los individuos y finalmentene, la quinta variable, llamada Ecivil, contiene la información del estado civil de cada uno de los individuos bajo observación. Pacientes_1 &lt;- data.frame(Nombre = c(&#39;Pedro&#39;, &#39;Ana&#39;, &#39;Luisa&#39;, &#39;Eva&#39;, &#39;Juan Carlos&#39;, &#39;Raul&#39;, &#39;Andrés&#39;, &#39;Juan&#39;, &#39;Ana Maria&#39;, &#39;Juana&#39;), Edad = c(35, 43, 34, 32, 34, 28, 23, 22, 25, 32), Social = c(1, 1, 1, 1, 2, 1, 1, 2, 2, 1), Sexo = c(&#39;H&#39;, &#39;M&#39;, &#39;M&#39;, &#39;M&#39;, &#39;H&#39;, &#39;H&#39;, &#39;H&#39;, &#39;H&#39;, &#39;M&#39;, &#39;M&#39;), ECivil = c(&#39;UL&#39;, &#39;C&#39;, &#39;S&#39;, &#39;UL&#39;, &#39;UL&#39;, &#39;C&#39;, &#39;UL&#39;, &#39;S&#39;, &#39;S&#39;, &#39;C&#39;)) En R, cuando se crea un marco de datos a través de la función data.frame, las variables que contienen información textual -vectores cadena o caracter- son importadas dentro del lenguaje, por defecto, como factores y los niveles levels de los mismos son conformados teniendo en cuenta un orden alfabético. Teniendo en cuenta lo anterior y los propósitos buscados con la creación de factores en R, realizar las siguientes actividades a partir del marco de datos hipotético Pacientes_1. Cree el marco de datos data.frame Pacientes_1 con las 5 variables de interés (Nombre, Edad, Social, Sexo y Ecivil). Imprima/presente los resultados y haga uso de la función str() para explorar el contenido de este marco de datos. ¿Qué características presentan las variables contenidas dentro de vectores de tipo cadena o caracter (Nombre, Sexo y Ecivil)? Renombre haciendo uso de la función factor() y el argumento levels los niveles/modalidades de la variable Ecivil de acuerdo a los siguientes criterios: Hombre = H y Mujer = M. Con la variable Sexo modificada, haciendo uso de la función table(), cree una tabla de frecuencias con la cantidad de Hombres y de Mujeres existente en el marco de datos Pacientes_1. Nota. Recuerde que para seleccionar o modificar el contenido una variable de un data.frame se debe hacer uso del operador $. Por ejemplo, la instrucción Pacientes_1$Sexo, nos permite seleccionar la variable Sexo del conjunto de datos Pacientes_1. Cualquier modificación al contenido de una variable dentro de un marco de datos debe tener en cuenta la anterior característica. Ordene y renombre, haciendo uso de la función factor() y los argumentos levels y labels, los niveles/modalidades de la variable Ecivil de acuerdo a los siguientes criterios: para levels usar las opciones UL, C y S y para labels las opciones Unión Libre, Casado y Soltero. Con la variable Ecivil ordenada y modificada, haciendo uso de la función table(), cree una tabla de frecuencias con la cantidad de individuos para cada uno de los estados civiles. Defina/cree en R, haciendo uso de la función factor(), un factor para representar la variable ordinal Social del conjunto de datos Pacientes_1. Los niveles (levels o/y labels) de esta variable son: 1 = Baja, 2 = Media y 3 = Alta en donde baja hace referencia a una condición social baja, media a una condición social media y alta, una condición social alta. Verifique, haciendo uso de la función str() o class(), la nueva condición de la variable Social la cual debe ser un factor de tipo ordinal. Así mismo, haciendo uso de la función table(), cree una tabla de frecuencias con la cantidad de individuos existente en cada una de las clases sociales. Nota. Ninguno de los individuos del data.frame bajo estudio (Pacientes_1) pertenece a la condición social alta (valor 3 en la variable Social). Es decir, esta condición debe aparacer con 0 individuos en la tabla de frecuencias. "]
]
